--- a/BlocksRunTime/Block.h	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/Block.h	2012-02-02 23:01:55.000000000 +0100
@@ -0,0 +1,59 @@
+/*
+ * Block.h
+ *
+ * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to permit
+ * persons to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef _BLOCK_H_
+#define _BLOCK_H_
+
+#if !defined(BLOCK_EXPORT)
+#   if defined(__cplusplus)
+#       define BLOCK_EXPORT extern "C" 
+#   else
+#       define BLOCK_EXPORT extern
+#   endif
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* Create a heap based copy of a Block or simply add a reference to an existing one.
+ * This must be paired with Block_release to recover memory, even when running
+ * under Objective-C Garbage Collection.
+ */
+BLOCK_EXPORT void *_Block_copy(const void *aBlock);
+
+/* Lose the reference, and if heap based and last reference, recover the memory. */
+BLOCK_EXPORT void _Block_release(const void *aBlock);
+
+#if defined(__cplusplus)
+}
+#endif
+
+/* Type correct macros. */
+
+#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))
+#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))
+
+
+#endif
--- a/BlocksRunTime/Block_private.h	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/Block_private.h	2012-02-02 23:01:55.000000000 +0100
@@ -0,0 +1,179 @@
+/*
+ * Block_private.h
+ *
+ * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to permit
+ * persons to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef _BLOCK_PRIVATE_H_
+#define _BLOCK_PRIVATE_H_
+
+#if !defined(BLOCK_EXPORT)
+#   if defined(__cplusplus)
+#       define BLOCK_EXPORT extern "C" 
+#   else
+#       define BLOCK_EXPORT extern
+#   endif
+#endif
+
+#ifndef _MSC_VER
+#include <stdbool.h>
+#else
+/* MSVC doesn't have <stdbool.h>. Compensate. */
+typedef char bool;
+#define true (bool)1
+#define false (bool)0
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+enum {
+    BLOCK_REFCOUNT_MASK =     (0xffff),
+    BLOCK_NEEDS_FREE =        (1 << 24),
+    BLOCK_HAS_COPY_DISPOSE =  (1 << 25),
+    BLOCK_HAS_CTOR =          (1 << 26), /* Helpers have C++ code. */
+    BLOCK_IS_GC =             (1 << 27),
+    BLOCK_IS_GLOBAL =         (1 << 28),
+    BLOCK_HAS_DESCRIPTOR =    (1 << 29)
+};
+
+
+/* Revised new layout. */
+struct Block_descriptor {
+    unsigned long int reserved;
+    unsigned long int size;
+    void (*copy)(void *dst, void *src);
+    void (*dispose)(void *);
+};
+
+
+struct Block_layout {
+    void *isa;
+    int flags;
+    int reserved; 
+    void (*invoke)(void *, ...);
+    struct Block_descriptor *descriptor;
+    /* Imported variables. */
+};
+
+
+struct Block_byref {
+    void *isa;
+    struct Block_byref *forwarding;
+    int flags; /* refcount; */
+    int size;
+    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
+    void (*byref_destroy)(struct Block_byref *);
+    /* long shared[0]; */
+};
+
+
+struct Block_byref_header {
+    void *isa;
+    struct Block_byref *forwarding;
+    int flags;
+    int size;
+};
+
+
+/* Runtime support functions used by compiler when generating copy/dispose helpers. */
+
+enum {
+    /* See function implementation for a more complete description of these fields and combinations */
+    BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */
+    BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */
+    BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */
+    BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */
+    BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */
+};
+
+/* Runtime entry point called by compiler when assigning objects inside copy helper routines */
+BLOCK_EXPORT void _Block_object_assign(void *destAddr, const void *object, const int flags);
+    /* BLOCK_FIELD_IS_BYREF is only used from within block copy helpers */
+
+
+/* runtime entry point called by the compiler when disposing of objects inside dispose helper routine */
+BLOCK_EXPORT void _Block_object_dispose(const void *object, const int flags);
+
+
+
+/* Other support functions */
+
+/* Runtime entry to get total size of a closure */
+BLOCK_EXPORT unsigned long int Block_size(void *block_basic);
+
+
+
+/* the raw data space for runtime classes for blocks */
+/* class+meta used for stack, malloc, and collectable based blocks */
+BLOCK_EXPORT void * _NSConcreteStackBlock[32];
+BLOCK_EXPORT void * _NSConcreteMallocBlock[32];
+BLOCK_EXPORT void * _NSConcreteAutoBlock[32];
+BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32];
+BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];
+BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32];
+
+
+/* the intercept routines that must be used under GC */
+BLOCK_EXPORT void _Block_use_GC( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
+                                  void (*setHasRefcount)(const void *, const bool),
+                                  void (*gc_assign_strong)(void *, void **),
+                                  void (*gc_assign_weak)(const void *, void *),
+                                  void (*gc_memmove)(void *, void *, unsigned long));
+
+/* earlier version, now simply transitional */
+BLOCK_EXPORT void _Block_use_GC5( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
+                                  void (*setHasRefcount)(const void *, const bool),
+                                  void (*gc_assign_strong)(void *, void **),
+                                  void (*gc_assign_weak)(const void *, void *));
+
+BLOCK_EXPORT void _Block_use_RR( void (*retain)(const void *),
+                                 void (*release)(const void *));
+
+/* make a collectable GC heap based Block.  Not useful under non-GC. */
+BLOCK_EXPORT void *_Block_copy_collectable(const void *aBlock);
+
+/* thread-unsafe diagnostic */
+BLOCK_EXPORT const char *_Block_dump(const void *block);
+
+
+/* Obsolete */
+
+/* first layout */
+struct Block_basic {
+    void *isa;
+    int Block_flags;  /* int32_t */
+    int Block_size;  /* XXX should be packed into Block_flags */
+    void (*Block_invoke)(void *);
+    void (*Block_copy)(void *dst, void *src);  /* iff BLOCK_HAS_COPY_DISPOSE */
+    void (*Block_dispose)(void *);             /* iff BLOCK_HAS_COPY_DISPOSE */
+    /* long params[0];  // where const imports, __block storage references, etc. get laid down */
+};
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+
+#endif /* _BLOCK_PRIVATE_H_ */
--- a/BlocksRunTime/config.h	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/config.h	2012-02-02 23:04:42.000000000 +0100
@@ -0,0 +1,49 @@
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+#ifdef __APPLE__
+
+#define HAVE_AVAILABILITY_MACROS_H 1
+#define HAVE_TARGET_CONDITIONALS_H 1
+#define HAVE_OSATOMIC_COMPARE_AND_SWAP_INT 1
+#define HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG 1
+#define HAVE_LIBKERN_OSATOMIC_H
+
+/* Be sneaky and turn OSAtomicCompareAndSwapInt into OSAtomicCompareAndSwap32
+ * and OSAtomicCompareAndSwapLong into either OSAtomicCompareAndSwap32
+ * or OSAtomicCompareAndSwap64 (depending on __LP64__) so that the library
+ * is Tiger compatible!
+ */
+#include <libkern/OSAtomic.h>
+#define OSAtomicCompareAndSwapInt OSAtomicCompareAndSwap32
+#ifdef __LP64__
+#define OSAtomicCompareAndSwapLong OSAtomicCompareAndSwap64
+#else
+#define OSAtomicCompareAndSwapLong OSAtomicCompareAndSwap32
+#endif
+
+#else /* !__APPLE__ */
+
+#ifdef __GNUC__
+
+#if !defined(__WIN32__) && !defined(_WIN32)
+
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) /* GCC >= 4.1 */
+
+/* runtime.c ignores these if __WIN32__ or _WIN32 is defined */
+#define HAVE_SYNC_BOOL_COMPARE_AND_SWAP_INT 1
+#define HAVE_SYNC_BOOL_COMPARE_AND_SWAP_LONG 1
+
+#else /* GCC earlier than version 4.1 */
+
+#error GCC version 4.1 (or compatible) or later is required on non-apple, non-w32 targets
+
+#endif /* GCC earlier than version 4.1 */
+
+#endif /* !defined(__WIN32__) && !defined(_WIN32) */
+
+#endif /* __GNUC__ */
+
+#endif /* !__APPLE__ */
+
+#endif /* _CONFIG_H_ */
diff -Naur a/BlocksRunTime/CREDITS.TXT b/BlocksRunTime/CREDITS.TXT
--- a/BlocksRunTime/CREDITS.TXT	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/CREDITS.TXT	2012-02-02 23:01:55.000000000 +0100
@@ -0,0 +1,24 @@
+This file is a partial list of people who have contributed to the LLVM/CompilerRT
+project.  If you have contributed a patch or made some other contribution to
+LLVM/CompilerRT, please submit a patch to this file to add yourself, and it will be
+done!
+
+The list is sorted by surname and formatted to allow easy grepping and
+beautification by scripts.  The fields are: name (N), email (E), web-address
+(W), PGP key ID and fingerprint (P), description (D), and snail-mail address
+(S).
+
+N: Craig van Vliet
+E: cvanvliet@auroraux.org
+W: http://www.auroraux.org
+D: Code style and Readability fixes.
+
+N: Edward O'Callaghan
+E: eocallaghan@auroraux.org
+W: http://www.auroraux.org
+D: CMake'ify Compiler-RT build system
+D: Maintain Solaris & AuroraUX ports of Compiler-RT
+
+N: Howard Hinnant
+E: hhinnant@apple.com
+D: Architect and primary author of compiler-rt
diff -Naur a/BlocksRunTime/data.c b/BlocksRunTime/data.c
--- a/BlocksRunTime/data.c	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/data.c	2012-02-02 23:01:55.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * data.c
+ *
+ * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to permit
+ * persons to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+/********************
+NSBlock support
+
+We allocate space and export a symbol to be used as the Class for the on-stack and malloc'ed copies until ObjC arrives on the scene.  These data areas are set up by Foundation to link in as real classes post facto.
+
+We keep these in a separate file so that we can include the runtime code in test subprojects but not include the data so that compiled code that sees the data in libSystem doesn't get confused by a second copy.  Somehow these don't get unified in a common block.
+**********************/
+
+void * _NSConcreteStackBlock[32] = { 0 };
+void * _NSConcreteMallocBlock[32] = { 0 };
+void * _NSConcreteAutoBlock[32] = { 0 };
+void * _NSConcreteFinalizingBlock[32] = { 0 };
+void * _NSConcreteGlobalBlock[32] = { 0 };
+void * _NSConcreteWeakBlockVariable[32] = { 0 };
+
+void _Block_copy_error(void) {
+}
diff -Naur a/BlocksRunTime/LICENSE.TXT b/BlocksRunTime/LICENSE.TXT
--- a/BlocksRunTime/LICENSE.TXT	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/LICENSE.TXT	2012-02-02 23:01:55.000000000 +0100
@@ -0,0 +1,76 @@
+==============================================================================
+compiler_rt License
+==============================================================================
+
+The compiler_rt library is dual licensed under both the University of Illinois
+"BSD-Like" license and the MIT license.  As a user of this code you may choose
+to use it under either license.  As a contributor, you agree to allow your code
+to be used under both.
+
+Full text of the relevant licenses is included below.
+
+==============================================================================
+
+University of Illinois/NCSA
+Open Source License
+
+Copyright (c) 2009-2012 by the contributors listed in CREDITS.TXT
+
+All rights reserved.
+
+Developed by:
+
+    LLVM Team
+
+    University of Illinois at Urbana-Champaign
+
+    http://llvm.org
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal with
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimers.
+
+    * Redistributions in binary form must reproduce the above copyright notice,
+      this list of conditions and the following disclaimers in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the names of the LLVM Team, University of Illinois at
+      Urbana-Champaign, nor the names of its contributors may be used to
+      endorse or promote products derived from this Software without specific
+      prior written permission.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
+SOFTWARE.
+
+==============================================================================
+
+Copyright (c) 2009-2012 by the contributors listed in CREDITS.TXT
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff -Naur a/BlocksRunTime/Makefile.lnx b/BlocksRunTime/Makefile.lnx
--- a/BlocksRunTime/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/Makefile.lnx	2012-02-02 23:08:11.000000000 +0100
@@ -0,0 +1,10 @@
+CFILES = data.c runtime.c
+OFILES = $(CFILES:.c=.o)
+
+libBlocksRunTime.a: $(OFILES)
+	ar rc $@ $?
+
+all: libBlocksRunTime.a
+
+clean:
+	$(RM) $(OFILES) libBlocksRunTime.a
diff -Naur a/BlocksRunTime/README.txt b/BlocksRunTime/README.txt
--- a/BlocksRunTime/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/README.txt	2012-02-02 23:01:55.000000000 +0100
@@ -0,0 +1,343 @@
+Compiler-RT
+================================
+
+This directory and its subdirectories contain source code for the compiler
+support routines.
+
+Compiler-RT is open source software. You may freely distribute it under the
+terms of the license agreement found in LICENSE.txt.
+
+================================
+
+This is a replacement library for libgcc.  Each function is contained
+in its own file.  Each function has a corresponding unit test under
+test/Unit.
+
+A rudimentary script to test each file is in the file called
+test/Unit/test.
+
+Here is the specification for this library:
+
+http://gcc.gnu.org/onlinedocs/gccint/Libgcc.html#Libgcc
+
+Here is a synopsis of the contents of this library:
+
+typedef      int si_int;
+typedef unsigned su_int;
+
+typedef          long long di_int;
+typedef unsigned long long du_int;
+
+// Integral bit manipulation
+
+di_int __ashldi3(di_int a, si_int b);      // a << b
+ti_int __ashlti3(ti_int a, si_int b);      // a << b
+
+di_int __ashrdi3(di_int a, si_int b);      // a >> b  arithmetic (sign fill)
+ti_int __ashrti3(ti_int a, si_int b);      // a >> b  arithmetic (sign fill)
+di_int __lshrdi3(di_int a, si_int b);      // a >> b  logical    (zero fill)
+ti_int __lshrti3(ti_int a, si_int b);      // a >> b  logical    (zero fill)
+
+si_int __clzsi2(si_int a);  // count leading zeros
+si_int __clzdi2(di_int a);  // count leading zeros
+si_int __clzti2(ti_int a);  // count leading zeros
+si_int __ctzsi2(si_int a);  // count trailing zeros
+si_int __ctzdi2(di_int a);  // count trailing zeros
+si_int __ctzti2(ti_int a);  // count trailing zeros
+
+si_int __ffsdi2(di_int a);  // find least significant 1 bit
+si_int __ffsti2(ti_int a);  // find least significant 1 bit
+
+si_int __paritysi2(si_int a);  // bit parity
+si_int __paritydi2(di_int a);  // bit parity
+si_int __parityti2(ti_int a);  // bit parity
+
+si_int __popcountsi2(si_int a);  // bit population
+si_int __popcountdi2(di_int a);  // bit population
+si_int __popcountti2(ti_int a);  // bit population
+
+uint32_t __bswapsi2(uint32_t a);   // a byteswapped, arm only
+uint64_t __bswapdi2(uint64_t a);   // a byteswapped, arm only
+
+// Integral arithmetic
+
+di_int __negdi2    (di_int a);                         // -a
+ti_int __negti2    (ti_int a);                         // -a
+di_int __muldi3    (di_int a, di_int b);               // a * b
+ti_int __multi3    (ti_int a, ti_int b);               // a * b
+si_int __divsi3    (si_int a, si_int b);               // a / b   signed
+di_int __divdi3    (di_int a, di_int b);               // a / b   signed
+ti_int __divti3    (ti_int a, ti_int b);               // a / b   signed
+su_int __udivsi3   (su_int n, su_int d);               // a / b   unsigned
+du_int __udivdi3   (du_int a, du_int b);               // a / b   unsigned
+tu_int __udivti3   (tu_int a, tu_int b);               // a / b   unsigned
+si_int __modsi3    (si_int a, si_int b);               // a % b   signed
+di_int __moddi3    (di_int a, di_int b);               // a % b   signed
+ti_int __modti3    (ti_int a, ti_int b);               // a % b   signed
+su_int __umodsi3   (su_int a, su_int b);               // a % b   unsigned
+du_int __umoddi3   (du_int a, du_int b);               // a % b   unsigned
+tu_int __umodti3   (tu_int a, tu_int b);               // a % b   unsigned
+du_int __udivmoddi4(du_int a, du_int b, du_int* rem);  // a / b, *rem = a % b  unsigned
+tu_int __udivmodti4(tu_int a, tu_int b, tu_int* rem);  // a / b, *rem = a % b  unsigned
+su_int __udivmodsi4(su_int a, su_int b, su_int* rem);  // a / b, *rem = a % b  unsigned
+si_int __divmodsi4(si_int a, si_int b, si_int* rem);   // a / b, *rem = a % b  signed
+
+
+
+//  Integral arithmetic with trapping overflow
+
+si_int __absvsi2(si_int a);           // abs(a)
+di_int __absvdi2(di_int a);           // abs(a)
+ti_int __absvti2(ti_int a);           // abs(a)
+
+si_int __negvsi2(si_int a);           // -a
+di_int __negvdi2(di_int a);           // -a
+ti_int __negvti2(ti_int a);           // -a
+
+si_int __addvsi3(si_int a, si_int b);  // a + b
+di_int __addvdi3(di_int a, di_int b);  // a + b
+ti_int __addvti3(ti_int a, ti_int b);  // a + b
+
+si_int __subvsi3(si_int a, si_int b);  // a - b
+di_int __subvdi3(di_int a, di_int b);  // a - b
+ti_int __subvti3(ti_int a, ti_int b);  // a - b
+
+si_int __mulvsi3(si_int a, si_int b);  // a * b
+di_int __mulvdi3(di_int a, di_int b);  // a * b
+ti_int __mulvti3(ti_int a, ti_int b);  // a * b
+
+
+// Integral arithmetic which returns if overflow
+
+si_int __mulosi4(si_int a, si_int b, int* overflow);  // a * b, overflow set to one if result not in signed range
+di_int __mulodi4(di_int a, di_int b, int* overflow);  // a * b, overflow set to one if result not in signed range
+ti_int __muloti4(ti_int a, ti_int b, int* overflow);  // a * b, overflow set to
+ one if result not in signed range
+
+
+//  Integral comparison: a  < b -> 0
+//                       a == b -> 1
+//                       a  > b -> 2
+
+si_int __cmpdi2 (di_int a, di_int b);
+si_int __cmpti2 (ti_int a, ti_int b);
+si_int __ucmpdi2(du_int a, du_int b);
+si_int __ucmpti2(tu_int a, tu_int b);
+
+//  Integral / floating point conversion
+
+di_int __fixsfdi(      float a);
+di_int __fixdfdi(     double a);
+di_int __fixxfdi(long double a);
+
+ti_int __fixsfti(      float a);
+ti_int __fixdfti(     double a);
+ti_int __fixxfti(long double a);
+uint64_t __fixtfdi(long double input);  // ppc only, doesn't match documentation
+
+su_int __fixunssfsi(      float a);
+su_int __fixunsdfsi(     double a);
+su_int __fixunsxfsi(long double a);
+
+du_int __fixunssfdi(      float a);
+du_int __fixunsdfdi(     double a);
+du_int __fixunsxfdi(long double a);
+
+tu_int __fixunssfti(      float a);
+tu_int __fixunsdfti(     double a);
+tu_int __fixunsxfti(long double a);
+uint64_t __fixunstfdi(long double input);  // ppc only
+
+float       __floatdisf(di_int a);
+double      __floatdidf(di_int a);
+long double __floatdixf(di_int a);
+long double __floatditf(int64_t a);        // ppc only
+
+float       __floattisf(ti_int a);
+double      __floattidf(ti_int a);
+long double __floattixf(ti_int a);
+
+float       __floatundisf(du_int a);
+double      __floatundidf(du_int a);
+long double __floatundixf(du_int a);
+long double __floatunditf(uint64_t a);     // ppc only
+
+float       __floatuntisf(tu_int a);
+double      __floatuntidf(tu_int a);
+long double __floatuntixf(tu_int a);
+
+//  Floating point raised to integer power
+
+float       __powisf2(      float a, si_int b);  // a ^ b
+double      __powidf2(     double a, si_int b);  // a ^ b
+long double __powixf2(long double a, si_int b);  // a ^ b
+long double __powitf2(long double a, si_int b);  // ppc only, a ^ b
+
+//  Complex arithmetic
+
+//  (a + ib) * (c + id)
+
+      float _Complex __mulsc3( float a,  float b,  float c,  float d);
+     double _Complex __muldc3(double a, double b, double c, double d);
+long double _Complex __mulxc3(long double a, long double b,
+                              long double c, long double d);
+long double _Complex __multc3(long double a, long double b,
+                              long double c, long double d); // ppc only
+
+//  (a + ib) / (c + id)
+
+      float _Complex __divsc3( float a,  float b,  float c,  float d);
+     double _Complex __divdc3(double a, double b, double c, double d);
+long double _Complex __divxc3(long double a, long double b,
+                              long double c, long double d);
+long double _Complex __divtc3(long double a, long double b,
+                              long double c, long double d);  // ppc only
+
+
+//         Runtime support
+
+// __clear_cache() is used to tell process that new instructions have been
+// written to an address range.  Necessary on processors that do not have
+// a unified instuction and data cache.
+void __clear_cache(void* start, void* end);
+
+// __enable_execute_stack() is used with nested functions when a trampoline
+// function is written onto the stack and that page range needs to be made
+// executable.
+void __enable_execute_stack(void* addr);
+
+// __gcc_personality_v0() is normally only called by the system unwinder.
+// C code (as opposed to C++) normally does not need a personality function
+// because there are no catch clauses or destructors to be run.  But there
+// is a C language extension __attribute__((cleanup(func))) which marks local
+// variables as needing the cleanup function "func" to be run when the
+// variable goes out of scope.  That includes when an exception is thrown,
+// so a personality handler is needed.  
+_Unwind_Reason_Code __gcc_personality_v0(int version, _Unwind_Action actions,
+         uint64_t exceptionClass, struct _Unwind_Exception* exceptionObject,
+         _Unwind_Context_t context);
+
+// for use with some implementations of assert() in <assert.h>
+void __eprintf(const char* format, const char* assertion_expression,
+				const char* line, const char* file);
+				
+
+
+//   Power PC specific functions
+
+// There is no C interface to the saveFP/restFP functions.  They are helper
+// functions called by the prolog and epilog of functions that need to save
+// a number of non-volatile float point registers.  
+saveFP
+restFP
+
+// PowerPC has a standard template for trampoline functions.  This function
+// generates a custom trampoline function with the specific realFunc
+// and localsPtr values.
+void __trampoline_setup(uint32_t* trampOnStack, int trampSizeAllocated, 
+                                const void* realFunc, void* localsPtr);
+
+// adds two 128-bit double-double precision values ( x + y )
+long double __gcc_qadd(long double x, long double y);  
+
+// subtracts two 128-bit double-double precision values ( x - y )
+long double __gcc_qsub(long double x, long double y); 
+
+// multiples two 128-bit double-double precision values ( x * y )
+long double __gcc_qmul(long double x, long double y);  
+
+// divides two 128-bit double-double precision values ( x / y )
+long double __gcc_qdiv(long double a, long double b);  
+
+
+//    ARM specific functions
+
+// There is no C interface to the switch* functions.  These helper functions
+// are only needed by Thumb1 code for efficient switch table generation.
+switch16
+switch32
+switch8
+switchu8
+
+// There is no C interface to the *_vfp_d8_d15_regs functions.  There are
+// called in the prolog and epilog of Thumb1 functions.  When the C++ ABI use
+// SJLJ for exceptions, each function with a catch clause or destuctors needs
+// to save and restore all registers in it prolog and epliog.  But there is 
+// no way to access vector and high float registers from thumb1 code, so the 
+// compiler must add call outs to these helper functions in the prolog and 
+// epilog.
+restore_vfp_d8_d15_regs
+save_vfp_d8_d15_regs
+
+
+// Note: long ago ARM processors did not have floating point hardware support.
+// Floating point was done in software and floating point parameters were 
+// passed in integer registers.  When hardware support was added for floating
+// point, new *vfp functions were added to do the same operations but with 
+// floating point parameters in floating point registers.
+
+// Undocumented functions
+
+float  __addsf3vfp(float a, float b);   // Appears to return a + b
+double __adddf3vfp(double a, double b); // Appears to return a + b
+float  __divsf3vfp(float a, float b);   // Appears to return a / b
+double __divdf3vfp(double a, double b); // Appears to return a / b
+int    __eqsf2vfp(float a, float b);    // Appears to return  one
+                                        //     iff a == b and neither is NaN.
+int    __eqdf2vfp(double a, double b);  // Appears to return  one
+                                        //     iff a == b and neither is NaN.
+double __extendsfdf2vfp(float a);       // Appears to convert from
+                                        //     float to double.
+int    __fixdfsivfp(double a);          // Appears to convert from
+                                        //     double to int.
+int    __fixsfsivfp(float a);           // Appears to convert from
+                                        //     float to int.
+unsigned int __fixunssfsivfp(float a);  // Appears to convert from
+                                        //     float to unsigned int.
+unsigned int __fixunsdfsivfp(double a); // Appears to convert from
+                                        //     double to unsigned int.
+double __floatsidfvfp(int a);           // Appears to convert from
+                                        //     int to double.
+float __floatsisfvfp(int a);            // Appears to convert from
+                                        //     int to float.
+double __floatunssidfvfp(unsigned int a); // Appears to convert from
+                                        //     unisgned int to double.
+float __floatunssisfvfp(unsigned int a); // Appears to convert from
+                                        //     unisgned int to float.
+int __gedf2vfp(double a, double b);     // Appears to return __gedf2
+                                        //     (a >= b)
+int __gesf2vfp(float a, float b);       // Appears to return __gesf2
+                                        //     (a >= b)
+int __gtdf2vfp(double a, double b);     // Appears to return __gtdf2
+                                        //     (a > b)
+int __gtsf2vfp(float a, float b);       // Appears to return __gtsf2
+                                        //     (a > b)
+int __ledf2vfp(double a, double b);     // Appears to return __ledf2
+                                        //     (a <= b)
+int __lesf2vfp(float a, float b);       // Appears to return __lesf2
+                                        //     (a <= b)
+int __ltdf2vfp(double a, double b);     // Appears to return __ltdf2
+                                        //     (a < b)
+int __ltsf2vfp(float a, float b);       // Appears to return __ltsf2
+                                        //     (a < b)
+double __muldf3vfp(double a, double b); // Appears to return a * b
+float __mulsf3vfp(float a, float b);    // Appears to return a * b
+int __nedf2vfp(double a, double b);     // Appears to return __nedf2
+                                        //     (a != b)
+double __negdf2vfp(double a);           // Appears to return -a
+float __negsf2vfp(float a);             // Appears to return -a
+float __negsf2vfp(float a);             // Appears to return -a
+double __subdf3vfp(double a, double b); // Appears to return a - b
+float __subsf3vfp(float a, float b);    // Appears to return a - b
+float __truncdfsf2vfp(double a);        // Appears to convert from
+                                        //     double to float.
+int __unorddf2vfp(double a, double b);  // Appears to return __unorddf2
+int __unordsf2vfp(float a, float b);    // Appears to return __unordsf2
+
+
+Preconditions are listed for each function at the definition when there are any.
+Any preconditions reflect the specification at
+http://gcc.gnu.org/onlinedocs/gccint/Libgcc.html#Libgcc.
+
+Assumptions are listed in "int_lib.h", and in individual files.  Where possible
+assumptions are checked at compile time.
diff -Naur a/BlocksRunTime/runtime.c b/BlocksRunTime/runtime.c
--- a/BlocksRunTime/runtime.c	1970-01-01 01:00:00.000000000 +0100
+++ b/BlocksRunTime/runtime.c	2012-02-02 23:01:55.000000000 +0100
@@ -0,0 +1,700 @@
+/*
+ * runtime.c
+ *
+ * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to permit
+ * persons to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#include "Block_private.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "config.h"
+
+#ifdef HAVE_AVAILABILITY_MACROS_H
+#include <AvailabilityMacros.h>
+#endif /* HAVE_AVAILABILITY_MACROS_H */
+
+#ifdef HAVE_TARGET_CONDITIONALS_H
+#include <TargetConditionals.h>
+#endif /* HAVE_TARGET_CONDITIONALS_H */
+
+#if defined(HAVE_OSATOMIC_COMPARE_AND_SWAP_INT) && defined(HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG)
+
+#ifdef HAVE_LIBKERN_OSATOMIC_H
+#include <libkern/OSAtomic.h>
+#endif /* HAVE_LIBKERN_OSATOMIC_H */
+
+#elif defined(__WIN32__) || defined(_WIN32)
+#define _CRT_SECURE_NO_WARNINGS 1
+#include <windows.h>
+
+static __inline bool OSAtomicCompareAndSwapLong(long oldl, long newl, long volatile *dst) {
+    /* fixme barrier is overkill -- see objc-os.h */
+    long original = InterlockedCompareExchange(dst, newl, oldl);
+    return (original == oldl);
+}
+
+static __inline bool OSAtomicCompareAndSwapInt(int oldi, int newi, int volatile *dst) {
+    /* fixme barrier is overkill -- see objc-os.h */
+    int original = InterlockedCompareExchange(dst, newi, oldi);
+    return (original == oldi);
+}
+
+/*
+ * Check to see if the GCC atomic built-ins are available.  If we're on
+ * a 64-bit system, make sure we have an 8-byte atomic function
+ * available.
+ *
+ */
+
+#elif defined(HAVE_SYNC_BOOL_COMPARE_AND_SWAP_INT) && defined(HAVE_SYNC_BOOL_COMPARE_AND_SWAP_LONG)
+
+static __inline bool OSAtomicCompareAndSwapLong(long oldl, long newl, long volatile *dst) {
+  return __sync_bool_compare_and_swap(dst, oldl, newl);
+}
+
+static __inline bool OSAtomicCompareAndSwapInt(int oldi, int newi, int volatile *dst) {
+  return __sync_bool_compare_and_swap(dst, oldi, newi);
+}
+
+#else
+#error unknown atomic compare-and-swap primitive
+#endif /* HAVE_OSATOMIC_COMPARE_AND_SWAP_INT && HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG */
+
+
+/*
+ * Globals:
+ */
+
+static void *_Block_copy_class = _NSConcreteMallocBlock;
+static void *_Block_copy_finalizing_class = _NSConcreteMallocBlock;
+static int _Block_copy_flag = BLOCK_NEEDS_FREE;
+static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;
+
+static const int WANTS_ONE = (1 << 16);
+
+static bool isGC = false;
+
+/*
+ * Internal Utilities:
+ */
+
+#if 0
+static unsigned long int latching_incr_long(unsigned long int *where) {
+    while (1) {
+        unsigned long int old_value = *(volatile unsigned long int *)where;
+        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
+            return BLOCK_REFCOUNT_MASK;
+        }
+        if (OSAtomicCompareAndSwapLong(old_value, old_value+1, (volatile long int *)where)) {
+            return old_value+1;
+        }
+    }
+}
+#endif /* if 0 */
+
+static int latching_incr_int(int *where) {
+    while (1) {
+        int old_value = *(volatile int *)where;
+        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
+            return BLOCK_REFCOUNT_MASK;
+        }
+        if (OSAtomicCompareAndSwapInt(old_value, old_value+1, (volatile int *)where)) {
+            return old_value+1;
+        }
+    }
+}
+
+#if 0
+static int latching_decr_long(unsigned long int *where) {
+    while (1) {
+        unsigned long int old_value = *(volatile int *)where;
+        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
+            return BLOCK_REFCOUNT_MASK;
+        }
+        if ((old_value & BLOCK_REFCOUNT_MASK) == 0) {
+            return 0;
+        }
+        if (OSAtomicCompareAndSwapLong(old_value, old_value-1, (volatile long int *)where)) {
+            return old_value-1;
+        }
+    }
+}
+#endif /* if 0 */
+
+static int latching_decr_int(int *where) {
+    while (1) {
+        int old_value = *(volatile int *)where;
+        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
+            return BLOCK_REFCOUNT_MASK;
+        }
+        if ((old_value & BLOCK_REFCOUNT_MASK) == 0) {
+            return 0;
+        }
+        if (OSAtomicCompareAndSwapInt(old_value, old_value-1, (volatile int *)where)) {
+            return old_value-1;
+        }
+    }
+}
+
+
+/*
+ * GC support stub routines:
+ */
+#if 0
+#pragma mark GC Support Routines
+#endif /* if 0 */
+
+
+static void *_Block_alloc_default(const unsigned long size, const bool initialCountIsOne, const bool isObject) {
+    return malloc(size);
+}
+
+static void _Block_assign_default(void *value, void **destptr) {
+    *destptr = value;
+}
+
+static void _Block_setHasRefcount_default(const void *ptr, const bool hasRefcount) {
+}
+
+static void _Block_do_nothing(const void *aBlock) { }
+
+static void _Block_retain_object_default(const void *ptr) {
+    if (!ptr) return;
+}
+
+static void _Block_release_object_default(const void *ptr) {
+    if (!ptr) return;
+}
+
+static void _Block_assign_weak_default(const void *ptr, void *dest) {
+    *(void **)dest = (void *)ptr;
+}
+
+static void _Block_memmove_default(void *dst, void *src, unsigned long size) {
+    memmove(dst, src, (size_t)size);
+}
+
+static void _Block_memmove_gc_broken(void *dest, void *src, unsigned long size) {
+    void **destp = (void **)dest;
+    void **srcp = (void **)src;
+    while (size) {
+        _Block_assign_default(*srcp, destp);
+        destp++;
+        srcp++;
+        size -= sizeof(void *);
+    }
+}
+
+/*
+ * GC support callout functions - initially set to stub routines:
+ */
+
+static void *(*_Block_allocator)(const unsigned long, const bool isOne, const bool isObject) = _Block_alloc_default;
+static void (*_Block_deallocator)(const void *) = (void (*)(const void *))free;
+static void (*_Block_assign)(void *value, void **destptr) = _Block_assign_default;
+static void (*_Block_setHasRefcount)(const void *ptr, const bool hasRefcount) = _Block_setHasRefcount_default;
+static void (*_Block_retain_object)(const void *ptr) = _Block_retain_object_default;
+static void (*_Block_release_object)(const void *ptr) = _Block_release_object_default;
+static void (*_Block_assign_weak)(const void *dest, void *ptr) = _Block_assign_weak_default;
+static void (*_Block_memmove)(void *dest, void *src, unsigned long size) = _Block_memmove_default;
+
+
+/*
+ * GC support SPI functions - called from ObjC runtime and CoreFoundation:
+ */
+
+/* Public SPI
+ * Called from objc-auto to turn on GC.
+ * version 3, 4 arg, but changed 1st arg
+ */
+void _Block_use_GC( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
+                    void (*setHasRefcount)(const void *, const bool),
+                    void (*gc_assign)(void *, void **),
+                    void (*gc_assign_weak)(const void *, void *),
+                    void (*gc_memmove)(void *, void *, unsigned long)) {
+
+    isGC = true;
+    _Block_allocator = alloc;
+    _Block_deallocator = _Block_do_nothing;
+    _Block_assign = gc_assign;
+    _Block_copy_flag = BLOCK_IS_GC;
+    _Block_copy_class = _NSConcreteAutoBlock;
+    /* blocks with ctors & dtors need to have the dtor run from a class with a finalizer */
+    _Block_copy_finalizing_class = _NSConcreteFinalizingBlock;
+    _Block_setHasRefcount = setHasRefcount;
+    _Byref_flag_initial_value = BLOCK_IS_GC;   // no refcount
+    _Block_retain_object = _Block_do_nothing;
+    _Block_release_object = _Block_do_nothing;
+    _Block_assign_weak = gc_assign_weak;
+    _Block_memmove = gc_memmove;
+}
+
+/* transitional */
+void _Block_use_GC5( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
+                    void (*setHasRefcount)(const void *, const bool),
+                    void (*gc_assign)(void *, void **),
+                    void (*gc_assign_weak)(const void *, void *)) {
+    /* until objc calls _Block_use_GC it will call us; supply a broken internal memmove implementation until then */
+    _Block_use_GC(alloc, setHasRefcount, gc_assign, gc_assign_weak, _Block_memmove_gc_broken);
+}
+
+ 
+/*
+ * Called from objc-auto to alternatively turn on retain/release.
+ * Prior to this the only "object" support we can provide is for those
+ * super special objects that live in libSystem, namely dispatch queues.
+ * Blocks and Block_byrefs have their own special entry points.
+ *
+ */
+void _Block_use_RR( void (*retain)(const void *),
+                    void (*release)(const void *)) {
+    _Block_retain_object = retain;
+    _Block_release_object = release;
+}
+
+/*
+ * Internal Support routines for copying:
+ */
+
+#if 0
+#pragma mark Copy/Release support
+#endif /* if 0 */
+
+/* Copy, or bump refcount, of a block.  If really copying, call the copy helper if present. */
+static void *_Block_copy_internal(const void *arg, const int flags) {
+    struct Block_layout *aBlock;
+    const bool wantsOne = (WANTS_ONE & flags) == WANTS_ONE;
+
+    //printf("_Block_copy_internal(%p, %x)\n", arg, flags);	
+    if (!arg) return NULL;
+    
+    
+    // The following would be better done as a switch statement
+    aBlock = (struct Block_layout *)arg;
+    if (aBlock->flags & BLOCK_NEEDS_FREE) {
+        // latches on high
+        latching_incr_int(&aBlock->flags);
+        return aBlock;
+    }
+    else if (aBlock->flags & BLOCK_IS_GC) {
+        // GC refcounting is expensive so do most refcounting here.
+        if (wantsOne && ((latching_incr_int(&aBlock->flags) & BLOCK_REFCOUNT_MASK) == 1)) {
+            // Tell collector to hang on this - it will bump the GC refcount version
+            _Block_setHasRefcount(aBlock, true);
+        }
+        return aBlock;
+    }
+    else if (aBlock->flags & BLOCK_IS_GLOBAL) {
+        return aBlock;
+    }
+
+    // Its a stack block.  Make a copy.
+    if (!isGC) {
+        struct Block_layout *result = malloc(aBlock->descriptor->size);
+        if (!result) return (void *)0;
+        memmove(result, aBlock, aBlock->descriptor->size); // bitcopy first
+        // reset refcount
+        result->flags &= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
+        result->flags |= BLOCK_NEEDS_FREE | 1;
+        result->isa = _NSConcreteMallocBlock;
+        if (result->flags & BLOCK_HAS_COPY_DISPOSE) {
+            //printf("calling block copy helper %p(%p, %p)...\n", aBlock->descriptor->copy, result, aBlock);
+            (*aBlock->descriptor->copy)(result, aBlock); // do fixup
+        }
+        return result;
+    }
+    else {
+        // Under GC want allocation with refcount 1 so we ask for "true" if wantsOne
+        // This allows the copy helper routines to make non-refcounted block copies under GC
+        unsigned long int flags = aBlock->flags;
+        bool hasCTOR = (flags & BLOCK_HAS_CTOR) != 0;
+        struct Block_layout *result = _Block_allocator(aBlock->descriptor->size, wantsOne, hasCTOR);
+        if (!result) return (void *)0;
+        memmove(result, aBlock, aBlock->descriptor->size); // bitcopy first
+        // reset refcount
+        // if we copy a malloc block to a GC block then we need to clear NEEDS_FREE.
+        flags &= ~(BLOCK_NEEDS_FREE|BLOCK_REFCOUNT_MASK);   // XXX not needed
+        if (wantsOne)
+            flags |= BLOCK_IS_GC | 1;
+        else
+            flags |= BLOCK_IS_GC;
+        result->flags = flags;
+        if (flags & BLOCK_HAS_COPY_DISPOSE) {
+            //printf("calling block copy helper...\n");
+            (*aBlock->descriptor->copy)(result, aBlock); // do fixup
+        }
+        if (hasCTOR) {
+            result->isa = _NSConcreteFinalizingBlock;
+        }
+        else {
+            result->isa = _NSConcreteAutoBlock;
+        }
+        return result;
+    }
+}
+
+
+/*
+ * Runtime entry points for maintaining the sharing knowledge of byref data blocks.
+ *
+ * A closure has been copied and its fixup routine is asking us to fix up the reference to the shared byref data
+ * Closures that aren't copied must still work, so everyone always accesses variables after dereferencing the forwarding ptr.
+ * We ask if the byref pointer that we know about has already been copied to the heap, and if so, increment it.
+ * Otherwise we need to copy it and update the stack forwarding pointer
+ * XXX We need to account for weak/nonretained read-write barriers.
+ */
+
+static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
+    struct Block_byref **destp = (struct Block_byref **)dest;
+    struct Block_byref *src = (struct Block_byref *)arg;
+        
+    //printf("_Block_byref_assign_copy called, byref destp %p, src %p, flags %x\n", destp, src, flags);
+    //printf("src dump: %s\n", _Block_byref_dump(src));
+    if (src->forwarding->flags & BLOCK_IS_GC) {
+        ;   // don't need to do any more work
+    }
+    else if ((src->forwarding->flags & BLOCK_REFCOUNT_MASK) == 0) {
+        //printf("making copy\n");
+        // src points to stack
+        bool isWeak = ((flags & (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK)) == (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK));
+        // if its weak ask for an object (only matters under GC)
+        struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);
+        copy->flags = src->flags | _Byref_flag_initial_value; // non-GC one for caller, one for stack
+        copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
+        src->forwarding = copy;  // patch stack to point to heap copy
+        copy->size = src->size;
+        if (isWeak) {
+            copy->isa = &_NSConcreteWeakBlockVariable;  // mark isa field so it gets weak scanning
+        }
+        if (src->flags & BLOCK_HAS_COPY_DISPOSE) {
+            // Trust copy helper to copy everything of interest
+            // If more than one field shows up in a byref block this is wrong XXX
+            copy->byref_keep = src->byref_keep;
+            copy->byref_destroy = src->byref_destroy;
+            (*src->byref_keep)(copy, src);
+        }
+        else {
+            // just bits.  Blast 'em using _Block_memmove in case they're __strong
+            _Block_memmove(
+                (void *)&copy->byref_keep,
+                (void *)&src->byref_keep,
+                src->size - sizeof(struct Block_byref_header));
+        }
+    }
+    // already copied to heap
+    else if ((src->forwarding->flags & BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
+        latching_incr_int(&src->forwarding->flags);
+    }
+    // assign byref data block pointer into new Block
+    _Block_assign(src->forwarding, (void **)destp);
+}
+
+// Old compiler SPI
+static void _Block_byref_release(const void *arg) {
+    struct Block_byref *shared_struct = (struct Block_byref *)arg;
+    int refcount;
+
+    // dereference the forwarding pointer since the compiler isn't doing this anymore (ever?)
+    shared_struct = shared_struct->forwarding;
+    
+    //printf("_Block_byref_release %p called, flags are %x\n", shared_struct, shared_struct->flags);
+    // To support C++ destructors under GC we arrange for there to be a finalizer for this
+    // by using an isa that directs the code to a finalizer that calls the byref_destroy method.
+    if ((shared_struct->flags & BLOCK_NEEDS_FREE) == 0) {
+        return; // stack or GC or global
+    }
+    refcount = shared_struct->flags & BLOCK_REFCOUNT_MASK;
+    if (refcount <= 0) {
+        printf("_Block_byref_release: Block byref data structure at %p underflowed\n", arg);
+    }
+    else if ((latching_decr_int(&shared_struct->flags) & BLOCK_REFCOUNT_MASK) == 0) {
+        //printf("disposing of heap based byref block\n");
+        if (shared_struct->flags & BLOCK_HAS_COPY_DISPOSE) {
+            //printf("calling out to helper\n");
+            (*shared_struct->byref_destroy)(shared_struct);
+        }
+        _Block_deallocator((struct Block_layout *)shared_struct);
+    }
+}
+
+
+/*
+ *
+ * API supporting SPI
+ * _Block_copy, _Block_release, and (old) _Block_destroy
+ *
+ */
+
+#if 0
+#pragma mark SPI/API
+#endif /* if 0 */
+
+void *_Block_copy(const void *arg) {
+    return _Block_copy_internal(arg, WANTS_ONE);
+}
+
+
+// API entry point to release a copied Block
+void _Block_release(void *arg) {
+    struct Block_layout *aBlock = (struct Block_layout *)arg;
+    int32_t newCount;
+    if (!aBlock) return;
+    newCount = latching_decr_int(&aBlock->flags) & BLOCK_REFCOUNT_MASK;
+    if (newCount > 0) return;
+    // Hit zero
+    if (aBlock->flags & BLOCK_IS_GC) {
+        // Tell GC we no longer have our own refcounts.  GC will decr its refcount
+        // and unless someone has done a CFRetain or marked it uncollectable it will
+        // now be subject to GC reclamation.
+        _Block_setHasRefcount(aBlock, false);
+    }
+    else if (aBlock->flags & BLOCK_NEEDS_FREE) {
+        if (aBlock->flags & BLOCK_HAS_COPY_DISPOSE)(*aBlock->descriptor->dispose)(aBlock);
+        _Block_deallocator(aBlock);
+    }
+    else if (aBlock->flags & BLOCK_IS_GLOBAL) {
+        ;
+    }
+    else {
+        printf("Block_release called upon a stack Block: %p, ignored\n", (void *)aBlock);
+    }
+}
+
+
+
+// Old Compiler SPI point to release a copied Block used by the compiler in dispose helpers
+static void _Block_destroy(const void *arg) {
+    struct Block_layout *aBlock;
+    if (!arg) return;
+    aBlock = (struct Block_layout *)arg;
+    if (aBlock->flags & BLOCK_IS_GC) {
+        // assert(aBlock->Block_flags & BLOCK_HAS_CTOR);
+        return; // ignore, we are being called because of a DTOR
+    }
+    _Block_release(aBlock);
+}
+
+
+
+/*
+ *
+ * SPI used by other layers
+ *
+ */
+
+// SPI, also internal.  Called from NSAutoBlock only under GC
+void *_Block_copy_collectable(const void *aBlock) {
+    return _Block_copy_internal(aBlock, 0);
+}
+
+
+// SPI
+unsigned long int Block_size(void *arg) {
+    return ((struct Block_layout *)arg)->descriptor->size;
+}
+
+
+#if 0
+#pragma mark Compiler SPI entry points
+#endif /* if 0 */
+
+    
+/*******************************************************
+
+Entry points used by the compiler - the real API!
+
+
+A Block can reference four different kinds of things that require help when the Block is copied to the heap.
+1) C++ stack based objects
+2) References to Objective-C objects
+3) Other Blocks
+4) __block variables
+
+In these cases helper functions are synthesized by the compiler for use in Block_copy and Block_release, called the copy and dispose helpers.  The copy helper emits a call to the C++ const copy constructor for C++ stack based objects and for the rest calls into the runtime support function _Block_object_assign.  The dispose helper has a call to the C++ destructor for case 1 and a call into _Block_object_dispose for the rest.
+
+The flags parameter of _Block_object_assign and _Block_object_dispose is set to
+	* BLOCK_FIELD_IS_OBJECT (3), for the case of an Objective-C Object,
+	* BLOCK_FIELD_IS_BLOCK (7), for the case of another Block, and
+	* BLOCK_FIELD_IS_BYREF (8), for the case of a __block variable.
+If the __block variable is marked weak the compiler also or's in BLOCK_FIELD_IS_WEAK (16).
+
+So the Block copy/dispose helpers should only ever generate the four flag values of 3, 7, 8, and 24.
+
+When  a __block variable is either a C++ object, an Objective-C object, or another Block then the compiler also generates copy/dispose helper functions.  Similarly to the Block copy helper, the "__block" copy helper (formerly and still a.k.a. "byref" copy helper) will do a C++ copy constructor (not a const one though!) and the dispose helper will do the destructor.  And similarly the helpers will call into the same two support functions with the same values for objects and Blocks with the additional BLOCK_BYREF_CALLER (128) bit of information supplied.
+
+So the __block copy/dispose helpers will generate flag values of 3 or 7 for objects and Blocks respectively, with BLOCK_FIELD_IS_WEAK (16) or'ed as appropriate and always 128 or'd in, for the following set of possibilities:
+	__block id                   128+3
+        __weak block id              128+3+16
+	__block (^Block)             128+7
+	__weak __block (^Block)      128+7+16
+        
+The implementation of the two routines would be improved by switch statements enumerating the eight cases.
+
+********************************************************/
+
+/*
+ * When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point
+ * to do the assignment.
+ */
+void _Block_object_assign(void *destAddr, const void *object, const int flags) {
+    //printf("_Block_object_assign(*%p, %p, %x)\n", destAddr, object, flags);
+    if ((flags & BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {
+        if ((flags & BLOCK_FIELD_IS_WEAK) == BLOCK_FIELD_IS_WEAK) {
+            _Block_assign_weak(object, destAddr);
+        }
+        else {
+            // do *not* retain or *copy* __block variables whatever they are
+            _Block_assign((void *)object, destAddr);
+        }
+    }
+    else if ((flags & BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {
+        // copying a __block reference from the stack Block to the heap
+        // flags will indicate if it holds a __weak reference and needs a special isa
+        _Block_byref_assign_copy(destAddr, object, flags);
+    }
+    // (this test must be before next one)
+    else if ((flags & BLOCK_FIELD_IS_BLOCK) == BLOCK_FIELD_IS_BLOCK) {
+        // copying a Block declared variable from the stack Block to the heap
+        _Block_assign(_Block_copy_internal(object, flags), destAddr);
+    }
+    // (this test must be after previous one)
+    else if ((flags & BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {
+        //printf("retaining object at %p\n", object);
+        _Block_retain_object(object);
+        //printf("done retaining object at %p\n", object);
+        _Block_assign((void *)object, destAddr);
+    }
+}
+
+// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point
+// to help dispose of the contents
+// Used initially only for __attribute__((NSObject)) marked pointers.
+void _Block_object_dispose(const void *object, const int flags) {
+    //printf("_Block_object_dispose(%p, %x)\n", object, flags);
+    if (flags & BLOCK_FIELD_IS_BYREF)  {
+        // get rid of the __block data structure held in a Block
+        _Block_byref_release(object);
+    }
+    else if ((flags & (BLOCK_FIELD_IS_BLOCK|BLOCK_BYREF_CALLER)) == BLOCK_FIELD_IS_BLOCK) {
+        // get rid of a referenced Block held by this Block
+        // (ignore __block Block variables, compiler doesn't need to call us)
+        _Block_destroy(object);
+    }
+    else if ((flags & (BLOCK_FIELD_IS_WEAK|BLOCK_FIELD_IS_BLOCK|BLOCK_BYREF_CALLER)) == BLOCK_FIELD_IS_OBJECT) {
+        // get rid of a referenced object held by this Block
+        // (ignore __block object variables, compiler doesn't need to call us)
+        _Block_release_object(object);
+    }
+}
+
+
+/*
+ * Debugging support:
+ */
+#if 0
+#pragma mark Debugging
+#endif /* if 0 */
+
+
+const char *_Block_dump(const void *block) {
+    struct Block_layout *closure = (struct Block_layout *)block;
+    static char buffer[512];
+    char *cp = buffer;
+    if (closure == NULL) {
+        sprintf(cp, "NULL passed to _Block_dump\n");
+        return buffer;
+    }
+    if (! (closure->flags & BLOCK_HAS_DESCRIPTOR)) {
+        printf("Block compiled by obsolete compiler, please recompile source for this Block\n");
+        exit(1);
+    }
+    cp += sprintf(cp, "^%p (new layout) =\n", (void *)closure);
+    if (closure->isa == NULL) {
+        cp += sprintf(cp, "isa: NULL\n");
+    }
+    else if (closure->isa == _NSConcreteStackBlock) {
+        cp += sprintf(cp, "isa: stack Block\n");
+    }
+    else if (closure->isa == _NSConcreteMallocBlock) {
+        cp += sprintf(cp, "isa: malloc heap Block\n");
+    }
+    else if (closure->isa == _NSConcreteAutoBlock) {
+        cp += sprintf(cp, "isa: GC heap Block\n");
+    }
+    else if (closure->isa == _NSConcreteGlobalBlock) {
+        cp += sprintf(cp, "isa: global Block\n");
+    }
+    else if (closure->isa == _NSConcreteFinalizingBlock) {
+        cp += sprintf(cp, "isa: finalizing Block\n");
+    }
+    else {
+        cp += sprintf(cp, "isa?: %p\n", (void *)closure->isa);
+    }
+    cp += sprintf(cp, "flags:");
+    if (closure->flags & BLOCK_HAS_DESCRIPTOR) {
+        cp += sprintf(cp, " HASDESCRIPTOR");
+    }
+    if (closure->flags & BLOCK_NEEDS_FREE) {
+        cp += sprintf(cp, " FREEME");
+    }
+    if (closure->flags & BLOCK_IS_GC) {
+        cp += sprintf(cp, " ISGC");
+    }
+    if (closure->flags & BLOCK_HAS_COPY_DISPOSE) {
+        cp += sprintf(cp, " HASHELP");
+    }
+    if (closure->flags & BLOCK_HAS_CTOR) {
+        cp += sprintf(cp, " HASCTOR");
+    }
+    cp += sprintf(cp, "\nrefcount: %u\n", closure->flags & BLOCK_REFCOUNT_MASK);
+    cp += sprintf(cp, "invoke: %p\n", (void *)(uintptr_t)closure->invoke);
+    {
+        struct Block_descriptor *dp = closure->descriptor;
+        cp += sprintf(cp, "descriptor: %p\n", (void *)dp);
+        cp += sprintf(cp, "descriptor->reserved: %lu\n", dp->reserved);
+        cp += sprintf(cp, "descriptor->size: %lu\n", dp->size);
+
+        if (closure->flags & BLOCK_HAS_COPY_DISPOSE) {
+            cp += sprintf(cp, "descriptor->copy helper: %p\n", (void *)(uintptr_t)dp->copy);
+            cp += sprintf(cp, "descriptor->dispose helper: %p\n", (void *)(uintptr_t)dp->dispose);
+        }
+    }
+    return buffer;
+}
+
+
+const char *_Block_byref_dump(struct Block_byref *src) {
+    static char buffer[256];
+    char *cp = buffer;
+    cp += sprintf(cp, "byref data block %p contents:\n", (void *)src);
+    cp += sprintf(cp, "  forwarding: %p\n", (void *)src->forwarding);
+    cp += sprintf(cp, "  flags: 0x%x\n", src->flags);
+    cp += sprintf(cp, "  size: %d\n", src->size);
+    if (src->flags & BLOCK_HAS_COPY_DISPOSE) {
+        cp += sprintf(cp, "  copy helper: %p\n", (void *)(uintptr_t)src->byref_keep);
+        cp += sprintf(cp, "  dispose helper: %p\n", (void *)(uintptr_t)src->byref_destroy);
+    }
+    return buffer;
+}
+
diff -Naur a/fsck_hfs.tproj/cache.c b/fsck_hfs.tproj/cache.c
--- a/fsck_hfs.tproj/cache.c	2008-11-18 22:15:07.000000000 +0100
+++ b/fsck_hfs.tproj/cache.c	2012-02-01 18:17:19.000000000 +0100
@@ -27,7 +27,11 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#if LINUX
+#include "missing.h"
+#else
 #include <sys/types.h>
+#endif /* __LINUX__ */
 #include <sys/uio.h>
 #include <unistd.h>
 #include <string.h>
diff -Naur a/fsck_hfs.tproj/dfalib/BlockCache.c b/fsck_hfs.tproj/dfalib/BlockCache.c
--- a/fsck_hfs.tproj/dfalib/BlockCache.c	2009-10-21 23:27:20.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/BlockCache.c	2012-02-01 18:17:19.000000000 +0100
@@ -21,6 +21,9 @@
  * @APPLE_LICENSE_HEADER_END@
  */
 
+#if LINUX
+#include "missing.h"
+#endif
 #include "SRuntime.h"
 #include "Scavenger.h"
 #include "../cache.h"
diff -Naur a/fsck_hfs.tproj/dfalib/BTree.c b/fsck_hfs.tproj/dfalib/BTree.c
--- a/fsck_hfs.tproj/dfalib/BTree.c	2010-05-08 00:54:28.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/BTree.c	2012-02-01 18:17:19.000000000 +0100
@@ -1709,7 +1709,9 @@
 								 UInt16					 version,
 								 BTreeInfoRec			*info )
 {
+#if !LINUX
 #pragma unused (version)
+#endif
 
 	BTreeControlBlockPtr	btreePtr;
 
diff -Naur a/fsck_hfs.tproj/dfalib/BTreeTreeOps.c b/fsck_hfs.tproj/dfalib/BTreeTreeOps.c
--- a/fsck_hfs.tproj/dfalib/BTreeTreeOps.c	2010-05-08 00:54:28.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/BTreeTreeOps.c	2012-02-01 18:17:19.000000000 +0100
@@ -447,7 +447,7 @@
 		M_ExitOnError (err);
 		
 		if ( DEBUG_BUILD && updateParent && newRoot )
-			DebugStr("\p InsertLevel: New root from primary key, update from secondary key...");
+			DebugStr("InsertLevel: New root from primary key, update from secondary key...");
 	}
 
 	//////////////////////// Update Parent(s) ///////////////////////////////
@@ -462,7 +462,7 @@
 		
 		secondaryKey = nil;
 		
-		PanicIf ( (level == btreePtr->treeDepth), "\p InsertLevel: unfinished insert!?");
+		PanicIf ( (level == btreePtr->treeDepth), "InsertLevel: unfinished insert!?");
 
 		++level;
 
@@ -470,7 +470,7 @@
 		index = treePathTable [level].index;
 		parentNodeNum = treePathTable [level].node;
 
-		PanicIf ( parentNodeNum == 0, "\p InsertLevel: parent node is zero!?");
+		PanicIf ( parentNodeNum == 0, "InsertLevel: parent node is zero!?");
 
 		err = GetNode (btreePtr, parentNodeNum, &parentNode);	// released as target node in next level up
 		M_ExitOnError (err);
@@ -484,7 +484,7 @@
 		{
 			//debug: check if ptr == targetNodeNum
 			GetRecordByIndex (btreePtr, parentNode.buffer, index, &keyPtr, &recPtr, &recSize);
-			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "\p InsertLevel: parent ptr doesn't match target node!");
+			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "InsertLevel: parent ptr doesn't match target node!");
 			
 			// need to delete and re-insert this parent key/ptr
 			// we delete it here and it gets re-inserted in the
@@ -546,7 +546,7 @@
 	(void) ReleaseNode (btreePtr, targetNode);
 	(void) ReleaseNode (btreePtr, &siblingNode);
 
-	Panic ("\p InsertLevel: an error occured!");
+	Panic ("InsertLevel: an error occured!");
 
 	return	err;
 
@@ -580,7 +580,7 @@
 
 	*rootSplit = false;
 	
-	PanicIf ( targetNode->buffer == siblingNode->buffer, "\p InsertNode: targetNode == siblingNode, huh?");
+	PanicIf ( targetNode->buffer == siblingNode->buffer, "InsertNode: targetNode == siblingNode, huh?");
 	
 	leftNodeNum = ((NodeDescPtr) targetNode->buffer)->bLink;
 	rightNodeNum = ((NodeDescPtr) targetNode->buffer)->fLink;
@@ -620,7 +620,7 @@
 	
 	if ( leftNodeNum > 0 )
 	{
-		PanicIf ( siblingNode->buffer != nil, "\p InsertNode: siblingNode already aquired!");
+		PanicIf ( siblingNode->buffer != nil, "InsertNode: siblingNode already aquired!");
 
 		if ( siblingNode->buffer == nil )
 		{
@@ -628,7 +628,7 @@
 			M_ExitOnError (err);
 		}
 
-		PanicIf ( ((NodeDescPtr) siblingNode->buffer)->fLink != nodeNum, "\p InsertNode, RotateLeft: invalid sibling link!" );
+		PanicIf ( ((NodeDescPtr) siblingNode->buffer)->fLink != nodeNum, "InsertNode, RotateLeft: invalid sibling link!" );
 
 		if ( !key->skipRotate )		// are rotates allowed?
 		{
@@ -717,7 +717,7 @@
 
 	targetNodeNum = treePathTable[level].node;
 	targetNodePtr = targetNode->buffer;
-	PanicIf (targetNodePtr == nil, "\pDeleteTree: targetNode has nil buffer!");
+	PanicIf (targetNodePtr == nil, "DeleteTree: targetNode has nil buffer!");
 
 	DeleteRecord (btreePtr, targetNodePtr, index);
 		
@@ -811,7 +811,7 @@
 			 
 			//debug: check if ptr == targetNodeNum
 			GetRecordByIndex (btreePtr, parentNode.buffer, index, &keyPtr, &recPtr, &recSize);
-			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "\p DeleteTree: parent ptr doesn't match targetNodeNum!!");
+			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, " DeleteTree: parent ptr doesn't match targetNodeNum!!");
 			
 			// need to delete and re-insert this parent key/ptr
 			DeleteRecord (btreePtr, parentNode.buffer, index);
@@ -1032,7 +1032,7 @@
 										keyPtr, keyLength, recPtr, recSize);
 			if ( !didItFit )
 			{
-				Panic ("\pRotateLeft: InsertKeyRecord (left) returned false!");
+				Panic ("RotateLeft: InsertKeyRecord (left) returned false!");
 				err = fsBTBadRotateErr;
 				goto ErrorExit;
 			}
@@ -1045,7 +1045,7 @@
 			didItFit = RotateRecordLeft (btreePtr, leftNode, rightNode);
 			if ( !didItFit )
 			{
-				Panic ("\pRotateLeft: RotateRecordLeft returned false!");
+				Panic ("RotateLeft: RotateRecordLeft returned false!");
 				err = fsBTBadRotateErr;
 				goto ErrorExit;
 			}
@@ -1062,7 +1062,7 @@
 									keyPtr, keyLength, recPtr, recSize);
 		if ( !didItFit )
 		{
-			Panic ("\pRotateLeft: InsertKeyRecord (right) returned false!");
+			Panic ("RotateLeft: InsertKeyRecord (right) returned false!");
 			err = fsBTBadRotateErr;
 			goto ErrorExit;
 		}
@@ -1131,7 +1131,7 @@
 	right = rightNode->buffer;
 	left  = leftNode->buffer;
 	
-	PanicIf ( right->bLink != 0 && left == 0, "\p SplitLeft: left sibling missing!?" );
+	PanicIf ( right->bLink != 0 && left == 0, " SplitLeft: left sibling missing!?" );
 	
 	// type should be kLeafNode or kIndexNode
 	
@@ -1254,8 +1254,8 @@
 	Boolean				didItFit;
 	UInt16				keyLength;	
 	
-	PanicIf (leftNode == nil, "\pAddNewRootNode: leftNode == nil");
-	PanicIf (rightNode == nil, "\pAddNewRootNode: rightNode == nil");
+	PanicIf (leftNode == nil, "AddNewRootNode: leftNode == nil");
+	PanicIf (rightNode == nil, "AddNewRootNode: rightNode == nil");
 	
 	
 	/////////////////////// Initialize New Root Node ////////////////////////////
@@ -1278,7 +1278,7 @@
 	didItFit = InsertKeyRecord ( btreePtr, rootNode.buffer, 0, keyPtr, keyLength,
 								 (UInt8 *) &rightNode->bLink, 4 );
 
-	PanicIf ( !didItFit, "\pAddNewRootNode:InsertKeyRecord failed for left index record");
+	PanicIf ( !didItFit, "AddNewRootNode:InsertKeyRecord failed for left index record");
 
 
 	//////////////////// Insert Right Node Index Record /////////////////////////
@@ -1289,7 +1289,7 @@
 	didItFit = InsertKeyRecord ( btreePtr, rootNode.buffer, 1, keyPtr, keyLength,
 								 (UInt8 *) &leftNode->fLink, 4 );
 
-	PanicIf ( !didItFit, "\pAddNewRootNode:InsertKeyRecord failed for right index record");
+	PanicIf ( !didItFit, "AddNewRootNode:InsertKeyRecord failed for right index record");
 
 
 #if DEBUG_TREEOPS
@@ -1369,7 +1369,7 @@
 	}
 	rightPtr = rightNodePtr->buffer;
 	
-	PanicIf ( leftPtr->fLink != 0 && rightPtr == 0, "\p SplitRight: right sibling missing!?" );
+	PanicIf ( leftPtr->fLink != 0 && rightPtr == 0, "SplitRight: right sibling missing!?" );
 	
 	// type should be kLeafNode or kIndexNode
 	
diff -Naur a/fsck_hfs.tproj/dfalib/hfs_endian.c b/fsck_hfs.tproj/dfalib/hfs_endian.c
--- a/fsck_hfs.tproj/dfalib/hfs_endian.c	2009-03-24 01:59:34.000000000 +0100
+++ b/fsck_hfs.tproj/dfalib/hfs_endian.c	2012-02-01 18:17:19.000000000 +0100
@@ -32,7 +32,9 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#if !LINUX
 #include <libkern/OSByteOrder.h>
+#endif
 #include <hfs/hfs_format.h>
 
 #include "Scavenger.h"
diff -Naur a/fsck_hfs.tproj/dfalib/hfs_endian.h b/fsck_hfs.tproj/dfalib/hfs_endian.h
--- a/fsck_hfs.tproj/dfalib/hfs_endian.h	2008-11-04 04:57:45.000000000 +0100
+++ b/fsck_hfs.tproj/dfalib/hfs_endian.h	2012-02-01 18:17:19.000000000 +0100
@@ -30,7 +30,9 @@
  * volume format.
  */
 #include <hfs/hfs_format.h>
+#if !LINUX
 #include <libkern/OSByteOrder.h>
+#endif
 #include "SRuntime.h"
 
 /*********************/
diff -Naur a/fsck_hfs.tproj/dfalib/Makefile b/fsck_hfs.tproj/dfalib/Makefile
--- a/fsck_hfs.tproj/dfalib/Makefile	2011-04-26 00:38:50.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/Makefile	2013-01-14 22:07:31.571100197 +0100
@@ -9,7 +9,7 @@
          BTree.c BTreeAllocate.c BTreeMiscOps.c \
          BTreeNodeOps.c BTreeScanner.c BTreeTreeOps.c\
          CatalogCheck.c HardLinkCheck.c dirhardlink.c \
-         SBTree.c SControl.c SVerify1.c SVerify2.c\
+         SBTree.c SVerify1.c SVerify2.c\
          SRepair.c SRebuildBTree.c\
          SUtils.c SKeyCompare.c SDevice.c SExtents.c SAllocate.c\
          SCatalog.c SStubs.c VolumeBitmapCheck.c uuid.c
diff -Naur a/fsck_hfs.tproj/dfalib/Makefile.lnx b/fsck_hfs.tproj/dfalib/Makefile.lnx
--- a/fsck_hfs.tproj/dfalib/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ b/fsck_hfs.tproj/dfalib/Makefile.lnx	2013-01-14 22:08:26.723401352 +0100
@@ -0,0 +1,15 @@
+CFILES = hfs_endian.c BlockCache.c\
+         BTree.c BTreeAllocate.c BTreeMiscOps.c \
+         BTreeNodeOps.c BTreeScanner.c BTreeTreeOps.c\
+         CatalogCheck.c HardLinkCheck.c\
+         SBTree.c SControl.c SVerify1.c SVerify2.c\
+         SRepair.c dirhardlink.c SRebuildBTree.c \
+         SUtils.c SKeyCompare.c SDevice.c SExtents.c SAllocate.c\
+         SCatalog.c SStubs.c VolumeBitmapCheck.c
+OFILES = $(CFILES:.c=.o)
+
+libdfa.a: $(OFILES)
+	ar rc $@ $?
+
+clean:
+	$(RM) $(OFILES) libdfa.a
diff -Naur a/fsck_hfs.tproj/dfalib/SBTree.c b/fsck_hfs.tproj/dfalib/SBTree.c
--- a/fsck_hfs.tproj/dfalib/SBTree.c	2009-10-21 23:27:20.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/SBTree.c	2012-02-01 18:17:19.000000000 +0100
@@ -102,7 +102,7 @@
 			CopyMemory(&resultIterator->key, foundKey, CalcKeySize(btcb, &resultIterator->key));	// warning, this could overflow user's buffer!!!
 
 		if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, *dataSize) )
-			DebugStr("\pSearchBTreeRecord: bad record?");
+			DebugStr("SearchBTreeRecord: bad record?");
 	}
 
 ErrorExit:
@@ -210,7 +210,7 @@
 		CopyMemory(&iterator->key, key, CalcKeySize(btcb, &iterator->key));	// warning, this could overflow user's buffer!!!
 		
 		if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, *dataSize) )
-			DebugStr("\pGetBTreeRecord: bad record?");
+			DebugStr("GetBTreeRecord: bad record?");
 
 	}
 	
@@ -242,7 +242,7 @@
 	CopyMemory(key, &iterator.key, CalcKeySize(btcb, (BTreeKey *) key));	// should we range check against maxkeylen?
 
 	if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, dataSize) )
-		DebugStr("\pInsertBTreeRecord: bad record?");
+		DebugStr("InsertBTreeRecord: bad record?");
 
 	result = BTInsertRecord( fcb, &iterator, &btRecord, dataSize );
 
@@ -304,7 +304,7 @@
 	CopyMemory(key, &iterator.key, CalcKeySize(btcb, (BTreeKey *) key));		// should we range check against maxkeylen?
 
 	if ( DEBUG_BUILD && !ValidHFSRecord(newData, btcb, dataSize) )
-		DebugStr("\pReplaceBTreeRecord: bad record?");
+		DebugStr("ReplaceBTreeRecord: bad record?");
 
 	result = BTReplaceRecord( fcb, &iterator, &btRecord, dataSize );
 
@@ -321,7 +321,9 @@
 OSStatus
 SetEndOfForkProc ( SFCB *filePtr, FSSize minEOF, FSSize maxEOF )
 {
+#if !LINUX
 #pragma unused (maxEOF)
+#endif
 
 	OSStatus	result;
 	UInt32		actualSectorsAdded;
@@ -341,7 +343,7 @@
 	else
 	{
 		if ( DEBUG_BUILD )
-			DebugStr("\pSetEndOfForkProc: minEOF is smaller than current size!");
+			DebugStr("SetEndOfForkProc: minEOF is smaller than current size!");
 		return -1;
 	}
 
@@ -367,7 +369,7 @@
 	//	Make sure we got at least as much space as we needed
 	//
 	if (filePtr->fcbLogicalSize < minEOF) {
-		Panic("\pSetEndOfForkProc: disk too full to extend B-tree file");
+		Panic("SetEndOfForkProc: disk too full to extend B-tree file");
 		return dskFulErr;
 	}
 	
@@ -439,7 +441,7 @@
 	if ( (keyLen < 6) || (keyLen > btcb->maxKeyLength) )
 	{
 		if ( DEBUG_BUILD )
-			DebugStr("\pCheckBTreeKey: bad key length!");
+			DebugStr("CheckBTreeKey: bad key length!");
 		return fsBTInvalidKeyLengthErr;
 	}
 	
diff -Naur a/fsck_hfs.tproj/dfalib/Scavenger.h b/fsck_hfs.tproj/dfalib/Scavenger.h
--- a/fsck_hfs.tproj/dfalib/Scavenger.h	2011-04-26 00:38:50.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/Scavenger.h	2012-02-01 18:17:19.000000000 +0100
@@ -41,10 +41,12 @@
 
 #include <assert.h>
 #include <sys/xattr.h>
+#if !LINUX
 #include <sys/acl.h>
 #include <sys/kauth.h>
-#include <sys/errno.h>
 #include <sys/syslimits.h>
+#endif
+#include <sys/errno.h>
 #include <sys/param.h>
 #include <sys/sysctl.h>
 #include <sys/mount.h>
diff -Naur a/fsck_hfs.tproj/dfalib/SControl.c b/fsck_hfs.tproj/dfalib/SControl.c
--- a/fsck_hfs.tproj/dfalib/SControl.c	2011-04-26 00:38:50.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/SControl.c	2013-01-14 22:06:42.364047171 +0100
@@ -34,6 +34,7 @@
 
 #define SHOW_ELAPSED_TIMES  0
 
+#include "missing.h"
 
 #if SHOW_ELAPSED_TIMES
 #include <sys/time.h>
@@ -55,7 +56,9 @@
  * correctly.  For all other ways to build the code, like 'make', the tag number will 
  * be left empty and only project name and build date/time will be shown.
  */
+#if !LINUX
 extern char __diskdev_cmds_version[]; 
+#endif
 
 int gGUIControl;
 extern char lflag;
@@ -219,7 +222,7 @@
 	int					isJournaled = 0;
 	Boolean 			autoRepair;
 	Boolean				exitEarly = 0;
-	__block int *msgCounts = NULL;
+	int *msgCounts = NULL;
 	Boolean				majorErrors = 0;
 
 	if (checkLevel == kMajorCheck) {
@@ -318,7 +321,7 @@
 	dataArea.DrvNum				= fsReadRef;
 	dataArea.liveVerifyState 	= liveMode;
 	dataArea.scanCount		= scanCount;
-    	if (strlcpy(dataArea.deviceNode, rdevnode, sizeof(dataArea.deviceNode)) != strlen(rdevnode)) {
+    	if (strncpy(dataArea.deviceNode, rdevnode, sizeof(dataArea.deviceNode)) != strlen(rdevnode)) {
 		dataArea.deviceNode[0] = '\0';
 	}
     	
diff -Naur a/fsck_hfs.tproj/dfalib/SDevice.c b/fsck_hfs.tproj/dfalib/SDevice.c
--- a/fsck_hfs.tproj/dfalib/SDevice.c	2008-11-04 04:57:45.000000000 +0100
+++ b/fsck_hfs.tproj/dfalib/SDevice.c	2012-02-01 18:17:19.000000000 +0100
@@ -28,24 +28,61 @@
 #include <unistd.h>
 #include <errno.h>
 #include <sys/ioctl.h>
-
+#if LINUX
+#include <fcntl.h>
+#include <sys/stat.h>
+#else
 #include <IOKit/storage/IOMediaBSDClient.h>
-
+#endif /* LINUX */
 #else
-
 #include <Files.h>
 #include <Device.h>
 #include <Disks.h>
 
-#endif
-
+#endif 
 
 OSErr GetDeviceSize(int driveRefNum, UInt64 *numBlocks, UInt32 *blockSize)
 {
 #if BSD
 	UInt64 devBlockCount = 0;
 	int devBlockSize = 0;
+#if LINUX
+	struct stat stbuf;
 
+	devBlockSize = 512;
+
+#ifndef BLKGETSIZE
+#define BLKGETSIZE              _IO(0x12,96)
+#endif
+#ifndef BLKGETSIZE64
+#define BLKGETSIZE64            _IOR(0x12,114,size_t)
+#endif
+	if (fstat(driveRefNum, &stbuf) < 0){
+		printf("Error: %s\n", strerror(errno));
+		return(-1);
+	}
+        
+        if (S_ISREG(stbuf.st_mode)) {
+                devBlockCount = stbuf.st_size / 512;
+        } 
+        else if (S_ISBLK(stbuf.st_mode)) {
+                unsigned long size;
+                u_int64_t size64;
+                if (!ioctl(driveRefNum, BLKGETSIZE64, &size64))
+                        devBlockCount = size64 / 512;
+                else if (!ioctl(driveRefNum, BLKGETSIZE, &size))
+                        devBlockCount = size;
+                else{
+                        printf("Error: %s\n", strerror(errno));
+			return(-1);
+		}
+			
+        }
+        else{
+                printf("Device is not a block device");
+		return(-1);
+	}
+#elif BSD
 	if (ioctl(driveRefNum, DKIOCGETBLOCKCOUNT, &devBlockCount) < 0) {
 		plog("ioctl(DKIOCGETBLOCKCOUNT) for fd %d: %s\n", driveRefNum, strerror(errno));
 		return (-1);
@@ -55,6 +92,7 @@
 		plog("ioctl(DKIOCGETBLOCKSIZE) for fd %d: %s\n", driveRefNum, strerror(errno));
 		return (-1);
 	}
+#endif /* BSD */
 
 	if (devBlockSize != 512) {
 		*numBlocks = (devBlockCount * (UInt64)devBlockSize) / 512;
diff -Naur a/fsck_hfs.tproj/dfalib/SKeyCompare.c b/fsck_hfs.tproj/dfalib/SKeyCompare.c
--- a/fsck_hfs.tproj/dfalib/SKeyCompare.c	2008-11-04 04:57:45.000000000 +0100
+++ b/fsck_hfs.tproj/dfalib/SKeyCompare.c	2012-02-01 18:17:19.000000000 +0100
@@ -453,7 +453,9 @@
  * The name portion of the key is compared using a 16-bit binary comparison. 
  * This is called from the b-tree code.
  */
+#if !LINUX
 __private_extern__
+#endif
 SInt32
 CompareAttributeKeys(const AttributeKey *searchKey, const AttributeKey *trialKey)
 {
diff -Naur a/fsck_hfs.tproj/dfalib/SRepair.c b/fsck_hfs.tproj/dfalib/SRepair.c
--- a/fsck_hfs.tproj/dfalib/SRepair.c	2010-11-18 01:24:49.000000000 +0100
+++ b/fsck_hfs.tproj/dfalib/SRepair.c	2012-02-01 18:17:19.000000000 +0100
@@ -2580,7 +2580,9 @@
 
 static	OSErr	FixWrapperExtents( SGlobPtr GPtr, RepairOrderPtr p )
 {
+#if !LINUX
 #pragma unused (p)
+#endif
 
 	OSErr						err;
 	HFSMasterDirectoryBlock		*mdb;
diff -Naur a/fsck_hfs.tproj/dfalib/SRuntime.h b/fsck_hfs.tproj/dfalib/SRuntime.h
--- a/fsck_hfs.tproj/dfalib/SRuntime.h	2011-04-26 00:38:50.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/SRuntime.h	2012-02-01 18:21:35.000000000 +0100
@@ -26,8 +26,11 @@
 #define __SRUNTIME__
 
 #if BSD
-
+#if LINUX
+#include "missing.h"
+#else
 #include <sys/types.h>
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -60,7 +63,7 @@
 typedef Ptr *		Handle;
 typedef u_int8_t	Byte;
 typedef size_t 		Size;
-typedef unsigned char	Boolean;
+//typedef unsigned char	Boolean;
 typedef u_int32_t	ItemCount;
 typedef u_int32_t	ByteCount;
 typedef u_int32_t	OptionBits;
@@ -71,7 +74,7 @@
 typedef u_int32_t	OSType;
 typedef u_int32_t	ResType;
 
-typedef u_int16_t	UniChar;
+//typedef u_int16_t	UniChar;
 typedef u_int32_t	UniCharCount;
 typedef UniChar *	UniCharArrayPtr;
 typedef const UniChar *	ConstUniCharArrayPtr;
@@ -89,10 +92,12 @@
 
 typedef u_int32_t	HFSCatalogNodeID;
 
+#if !LINUX
 enum {
 	false		= 0,
 	true		= 1
 };
+#endif
 
 /* OS error codes */
 enum {
diff -Naur a/fsck_hfs.tproj/dfalib/SUtils.c b/fsck_hfs.tproj/dfalib/SUtils.c
--- a/fsck_hfs.tproj/dfalib/SUtils.c	2008-11-04 04:57:45.000000000 +0100
+++ b/fsck_hfs.tproj/dfalib/SUtils.c	2012-02-01 18:17:19.000000000 +0100
@@ -471,7 +471,8 @@
 //				GPtr->realVCB			Real in-memory vcb
 //------------------------------------------------------------------------------
 
-#if !BSD	
+#if BSD
+#if !LINUX
 OSErr GetVolumeFeatures( SGlobPtr GPtr )
 {
 	OSErr					err;
@@ -509,7 +510,7 @@
 	return( noErr );
 }
 #endif
-
+#endif
 
 
 /*-------------------------------------------------------------------------------
diff -Naur a/fsck_hfs.tproj/dfalib/SVerify1.c b/fsck_hfs.tproj/dfalib/SVerify1.c
--- a/fsck_hfs.tproj/dfalib/SVerify1.c	2010-09-07 01:49:54.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/SVerify1.c	2012-02-01 18:17:19.000000000 +0100
@@ -40,7 +40,11 @@
 #include <fcntl.h>
 #include <limits.h>
 
+#if !LINUX
 #include <libkern/OSByteOrder.h>
+#else
+#define XATTR_MAXNAMELEN 127
+#endif
 #define SW16(x)	OSSwapBigToHostInt16(x)
 #define	SW32(x)	OSSwapBigToHostInt32(x)
 #define	SW64(x)	OSSwapBigToHostInt64(x)
@@ -345,7 +349,10 @@
 				jfd = dup(GPtr->DrvNum);
 			else {
 				if (debug)
-					plog("External Journal device\n");
+					plog("External Journal device\n - unsupported");
+#if LINUX
+				goto out;
+#endif
 				jfd = OpenDeviceByUUID(&jib.ext_jnl_uuid);
 			}
 
@@ -2548,7 +2555,7 @@
 	/* Always update the last recordType, fileID and attribute name before exiting */
 	prevAttr->recordType = rec->recordType;
 	prevAttr->fileID = fileID;
-	(void) strlcpy((char *)prevAttr->attrname, (char *)attrname, sizeof(prevAttr->attrname));
+	(void) strncpy((char *)prevAttr->attrname, (char *)attrname, sizeof(prevAttr->attrname));
 
 	goto out;
 
@@ -3555,6 +3562,7 @@
 /*
  * Build a catalog node thread key.
  */
+#if !LINUX
 __unused static void
 buildthreadkey(UInt32 parentID, int std_hfs, CatalogKey *key)
 {
@@ -3569,7 +3577,7 @@
 		key->hfsPlus.nodeName.length = 0;
 	}
 }
-
+#endif
 
 static void
 printpath(SGlobPtr GPtr, UInt32 fileID)
@@ -3957,7 +3965,7 @@
 		if (extentInfo.attrname == NULL) {
 			return(memFullErr);
 		}
-		strlcpy(extentInfo.attrname, attrname, attrlen);
+		strncpy(extentInfo.attrname, attrname, attrlen);
 	}
 	
 	//	If it's uninitialized
@@ -4465,6 +4473,9 @@
 //int journal_replay(SGlobPtr gptr)
 int journal_replay(const char *block_device)
 {
+#if LINUX
+	return 0;
+#else
 	int retval = 0;
 	struct vfsconf vfc;
 	int mib[4];
@@ -4495,5 +4506,6 @@
 
 out:
 	return retval;
+#endif
 }
  
diff -Naur a/fsck_hfs.tproj/dfalib/SVerify2.c b/fsck_hfs.tproj/dfalib/SVerify2.c
--- a/fsck_hfs.tproj/dfalib/SVerify2.c	2010-08-27 23:06:03.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/SVerify2.c	2012-02-01 18:17:19.000000000 +0100
@@ -31,7 +31,9 @@
 */
 
 #include <sys/ioctl.h>
+#if !LINUX
 #include <sys/disk.h>
+#endif
 
 #include "BTree.h"
 #include "BTreePrivate.h"
diff -Naur a/fsck_hfs.tproj/dfalib/uuid.c b/fsck_hfs.tproj/dfalib/uuid.c
--- a/fsck_hfs.tproj/dfalib/uuid.c	2010-06-30 01:54:11.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/uuid.c	2012-02-02 22:43:00.000000000 +0100
@@ -1,12 +1,16 @@
 #include <fcntl.h>
+#if !LINUX
 #include <util.h>
+#endif
 #include <unistd.h>
 #include <string.h>
 #include <sys/mount.h>
 #include <uuid/uuid.h>
+#if !LINUX
 #include <IOKit/IOBSD.h>
 #include <IOKit/IOKitLib.h>
 #include <IOKit/storage/IOMedia.h>
+#endif
 
 extern char debug;
 extern void plog(const char *, ...);
diff -Naur a/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c b/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c
--- a/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c	2011-04-26 00:38:50.000000000 +0200
+++ b/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c	2012-02-01 18:17:19.000000000 +0100
@@ -31,7 +31,9 @@
 
 #include "Scavenger.h"
 
+#if !LINUX
 #include <sys/disk.h>
+#endif
 
 #include <bitstring.h>
 
@@ -1080,18 +1082,23 @@
 	return error;
 }
 
+#if !LINUX
 enum { kMaxTrimExtents = 256 };
 dk_extent_t gTrimExtents[kMaxTrimExtents];
 dk_unmap_t gTrimData;
+#endif
 
 static void TrimInit(void)
 {
+#if !LINUX
 	bzero(&gTrimData, sizeof(gTrimData));
 	gTrimData.extents = gTrimExtents;
+#endif
 }
 
 static void TrimFlush(void)
 {
+#if !LINUX
 	int err;
 	
 	if (gTrimData.extentsCount == 0)
@@ -1106,10 +1113,12 @@
 		DPRINTF(d_error|d_trim, "TrimFlush: error %d\n", errno);
 	}
 	gTrimData.extentsCount = 0;
+#endif
 }
 
 static void TrimExtent(SGlobPtr g, UInt32 startBlock, UInt32 blockCount)
 {
+#if !LINUX
 	UInt64 offset;
 	UInt64 length;
 	
@@ -1126,6 +1135,7 @@
 	gTrimExtents[gTrimData.extentsCount].length = length;
 	if (++gTrimData.extentsCount == kMaxTrimExtents)
 		TrimFlush();
+#endif
 }
 
 /* Function: TrimFreeBlocks
@@ -1140,6 +1150,7 @@
  */
 void TrimFreeBlocks(SGlobPtr g)
 {
+#if !LINUX
 	UInt32 *buffer;
 	UInt32 bit;
 	UInt32 wordWithinSegment;
@@ -1237,6 +1248,7 @@
 	
 	TrimFlush();
 	DPRINTF(d_info|d_trim, "Trimmed %u allocation blocks.\n", totalTrimmed);
+#endif
 }
 
 /* Function: IsTrimSupported
@@ -1250,6 +1262,9 @@
  */
 int IsTrimSupported(void)
 {
+#if LINUX
+	return 0;
+#else
 	int err;
     uint32_t features = 0;
 	
@@ -1261,6 +1276,7 @@
 	}
 	
 	return features & DK_FEATURE_UNMAP;
+#endif
 }
 
 /*
diff -Naur a/fsck_hfs.tproj/fsck_hfs.c b/fsck_hfs.tproj/fsck_hfs.c
--- a/fsck_hfs.tproj/fsck_hfs.c	2010-08-27 23:06:03.000000000 +0200
+++ b/fsck_hfs.tproj/fsck_hfs.c	2012-02-01 18:17:19.000000000 +0100
@@ -23,15 +23,22 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
+#if !LINUX
 #include <sys/ucred.h>
+#endif
 #include <sys/mount.h>
 #include <sys/ioctl.h>
+#if !LINUX
 #include <sys/disk.h>
 #include <sys/sysctl.h>
 #include <setjmp.h>
-
+#endif
 #include <hfs/hfs_mount.h>
 
+#if LINUX
+#include <mntent.h>
+#endif
+
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -286,10 +293,12 @@
 	
 	if (guiControl)
 		debug = 0; /* debugging is for command line only */
-
+#if LINUX
+// FIXME
+#else
 	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
 		(void)signal(SIGINT, catch);
-
+#endif
 	if (argc < 1) {
 		(void) fplog(stderr, "%s: missing special-device\n", progname);
 		usage();
@@ -322,6 +331,10 @@
 	char *unraw = NULL;
 	int result;
 	int i;
+#if LINUX
+	FILE *fp = fopen("/proc/self/mounts", "r");
+	struct mntent *mntent;
+#endif
 
 	unraw = strdup(cdev);
 	unrawname(unraw);
@@ -329,6 +342,14 @@
 	if (unraw == NULL)
 		goto done;
 
+#if LINUX
+	while ((mntent = getmntent(fp))) {
+		if (strcmp(unraw, mntent->mnt_fsname) == 0) {
+			retval = strdup(mntent->mnt_dir);
+			break;
+		}
+	}
+#else
 	result = getmntinfo(&fsinfo, MNT_NOWAIT);
 
 	for (i = 0; i < result; i++) {
@@ -337,6 +358,7 @@
 			break;
 		}
 	}
+#endif
 
 done:
 	if (unraw)
@@ -375,6 +397,9 @@
 		mntonname = strdup("/");
 	}
 
+#if LINUX
+	// FIXME
+#else
 	if (lflag) {
 		struct stat fs_stat;
 
@@ -434,7 +459,7 @@
 			}
 		}
 	}
-
+#endif
 	if (debug && preen)
 		pwarn("starting\n");
 	
@@ -535,6 +560,9 @@
 			}
 		}
 	} else {
+#if LINUX
+	// FIXME
+#else
 		struct statfs stfs_buf;
 
 		/*
@@ -545,18 +573,23 @@
 		else
 			flags = 0;
 		ckfini(flags & MNT_RDONLY);
+#endif
 	}
-
 	/* XXX free any allocated memory here */
 
 	if (hotmount && fsmodified) {
+#if !LINUX
 		struct hfs_mount_args args;
+#endif
 		/*
 		 * We modified the root.  Do a mount update on
 		 * it, unless it is read-write, so we can continue.
 		 */
 		if (!preen)
 			fsckPrint(context, fsckVolumeModified);
+#if LINUX
+		// FIXME
+#else
 		if (flags & MNT_RDONLY) {
 			bzero(&args, sizeof(args));
 			flags |= MNT_UPDATE | MNT_RELOAD;
@@ -571,6 +604,7 @@
 					fprintf(stderr, "update/reload mount for %s failed: %s\n", mntonname, strerror(errno));
 			}
 		}
+#endif
 		if (!preen)
 			plog("\n***** REBOOT NOW *****\n");
 		sync();
@@ -620,11 +654,13 @@
 		plog("Can't stat %s: %s\n", dev, strerror(errno));
 		return (0);
 	}
+#if !LINUX
 	if ((statb.st_mode & S_IFMT) != S_IFCHR) {
 		pfatal("%s is not a character device", dev);
 		if (reply("CONTINUE") == 0)
 			return (0);
 	}
+#endif
 	/* Always attempt to replay the journal */
 	if (!nflag && !quick) {
 		// We know we have a character device by now.
@@ -644,6 +680,9 @@
 	if (preen == 0 && !guiControl)
 		plog("** %s", dev);
 
+#if LINUX
+#define O_EXLOCK 0
+#endif
 	if (nflag || quick || (fswritefd = open(dev, O_RDWR | (hotmount ? 0 : O_EXLOCK))) < 0) {
 		fswritefd = -1;
 		if (preen)
@@ -670,11 +709,14 @@
 
 
 	/* Get device block size to initialize cache */
+#if LINUX
+	devBlockSize = 512;
+#else
 	if (ioctl(fsreadfd, DKIOCGETBLOCKSIZE, &devBlockSize) < 0) {
 		pfatal ("Can't get device block size\n");
 		return (0);
 	}
-
+#endif
 	 /*
 	  * Calculate the cache block size and total blocks.
 	  *
@@ -698,6 +740,7 @@
 		size_t dsize = sizeof(memSize);
 		int rv;
 
+#if !LINUX
 		rv = sysctlbyname("hw.memsize", &memSize, &dsize, NULL, 0);
 		if (rv == -1) {
 			(void)fplog(stderr, "sysctlbyname failed, not auto-setting cache size\n");
@@ -705,6 +748,7 @@
 			int d = (hotroot && !lflag) ? 2 : 8;
 			reqCacheSize = memSize / d;
 		}
+#endif
 	}
 	
 	CalculateCacheSizes(reqCacheSize, &cacheBlockSize, &cacheTotalBlocks, debug);
@@ -730,11 +774,15 @@
 
 static void getWriteAccess( char *dev, int *canWritePtr )
 {
+#if !LINUX
 	int					i;
 	int					myMountsCount;
+#endif
 	void *				myPtr;
 	char *				myCharPtr;
+#if !LINUX
 	struct statfs *			myBufPtr;
+#endif
 	void *				myNamePtr;
 	int				blockDevice_fd = -1;
 
@@ -758,6 +806,9 @@
 	}
 	
 	// get count of mounts then get the info for each 
+#if LINUX
+	// FIXME
+#else
 	myMountsCount = getfsstat( NULL, 0, MNT_NOWAIT );
 	if ( myMountsCount < 0 )
 		goto ExitThisRoutine;
@@ -781,8 +832,8 @@
 		}
 		myBufPtr++;
 	}
+#endif
 	*canWritePtr = 1;  // single user will get us here, f_mntfromname is not /dev/diskXXXX 
-	
 ExitThisRoutine:
 	if ( myPtr != NULL )
 		free( myPtr );
--- a/fsck_hfs.tproj/fsck_messages.c	2010-01-28 00:47:55.000000000 +0100
+++ b/fsck_hfs.tproj/fsck_messages.c	2012-02-02 23:42:58.000000000 +0100
@@ -21,6 +21,7 @@
  * @APPLE_LICENSE_HEADER_END@
  */
 
+#define _GNU_SOURCE
 #include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -517,11 +518,20 @@
 				break;
 		}
 		if (rv == -1) {
+#if LINUX
+			char resp[80];
+#else
 			char *resp = NULL;
+#endif
 			size_t len;
 
 			count++;
+#if LINUX
+			fgets (resp, 80, stdin);
+			len = strlen(resp);
+#else
 			resp = fgetln(stdin, &len);
+#endif
 			if (resp == NULL || len == 0) {
 				if (count > 10) {
 					// Only ask so many times...
diff -Naur a/fsck_hfs.tproj/fsck_messages.h b/fsck_hfs.tproj/fsck_messages.h
--- a/fsck_hfs.tproj/fsck_messages.h	2010-01-28 00:47:55.000000000 +0100
+++ b/fsck_hfs.tproj/fsck_messages.h	2013-01-14 22:02:51.642416021 +0100
@@ -140,10 +140,10 @@
  * the third is a va_list of the arguments for the message.
  */
 
-typedef fsck_block_status_t (^fsckBlock_t)(fsck_ctx_t, int, va_list);
+//typedef fsck_block_status_t (^fsckBlock_t)(fsck_ctx_t, int, va_list);
 
-extern fsckBlock_t fsckGetBlock(fsck_ctx_t, fsck_block_phase_t);
-extern void fsckSetBlock(fsck_ctx_t, fsck_block_phase_t, fsckBlock_t);
+//extern fsckBlock_t fsckGetBlock(fsck_ctx_t, fsck_block_phase_t);
+//extern void fsckSetBlock(fsck_ctx_t, fsck_block_phase_t, fsckBlock_t);
 
 extern fsck_ctx_t fsckCreate(void);
 extern int fsckSetOutput(fsck_ctx_t, FILE*);
diff -Naur a/fsck_hfs.tproj/Makefile.lnx b/fsck_hfs.tproj/Makefile.lnx
--- a/fsck_hfs.tproj/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ b/fsck_hfs.tproj/Makefile.lnx	2013-01-14 22:05:16.338455758 +0100
@@ -0,0 +1,16 @@
+CFILES = fsck_hfs.c utilities.c cache.c fsck_debug.c fsck_hfs_strings.c fsck_strings.c
+OFILES = $(CFILES:.c=.o)
+
+all: fsck_hfs
+
+fsck_hfs: $(OFILES) dfalib/libdfa.a
+	  $(CC) $(CFLAGS) $(OFILES) dfalib/libdfa.a -o fsck_hfs -lBlocksRunTime -lpthread
+
+dfalib/libdfa.a: FORCE
+	$(MAKE) -C dfalib -f Makefile.lnx libdfa.a
+
+clean:
+	$(RM) fsck_hfs $(OFILES)
+	$(MAKE) -C dfalib -f Makefile.lnx clean
+
+.PHONY : FORCE clean
diff -Naur a/fsck_hfs.tproj/utilities.c b/fsck_hfs.tproj/utilities.c
--- a/fsck_hfs.tproj/utilities.c	2009-05-01 00:55:18.000000000 +0200
+++ b/fsck_hfs.tproj/utilities.c	2013-01-14 22:04:13.842848274 +0100
@@ -56,7 +56,12 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/errno.h>
+#if LINUX
+#include <limits.h>
+#include <signal.h>
+#else
 #include <sys/syslimits.h>
+#endif
 #include <pwd.h>
 
 #include <ctype.h>
@@ -186,12 +191,14 @@
 			plog("Can't stat %s\n", raw);
 			return (origname);
 		}
+#if !LINUX
 		if ((stchar.st_mode & S_IFMT) == S_IFCHR) {
 			return (raw);
 		} else {
 			plog("%s is not a character device\n", raw);
 			return (origname);
 		}
+#endif
 	} else if ((stblock.st_mode & S_IFMT) == S_IFCHR && !retried) {
 		newname = unrawname(newname);
 		retried++;
@@ -215,10 +222,14 @@
 	if ((dp = strrchr(name, '/')) == 0)
 		return (0);
 	*dp = 0;
-	(void)strlcpy(rawbuf, name, sizeof(rawbuf));
+	(void)strncpy(rawbuf, name, sizeof(rawbuf));
 	*dp = '/';
-	(void)strlcat(rawbuf, "/r", sizeof(rawbuf));
-	(void)strlcat(rawbuf, &dp[1], sizeof(rawbuf));
+#if LINUX
+	(void)strncat(rawbuf, "/", sizeof(rawbuf));
+#else
+	(void)strncat(rawbuf, "/r", sizeof(rawbuf));
+#endif
+	(void)strncat(rawbuf, &dp[1], sizeof(rawbuf));
 
 	return (rawbuf);
 }
@@ -531,13 +542,14 @@
 	    //
 	    in_mem_log = (char *)malloc(DEFAULT_IN_MEM_SIZE);
 	    if (in_mem_log) {
+		va_list ap;
 		in_mem_size = DEFAULT_IN_MEM_SIZE;
 		in_mem_log[0] = '\0';
 		cur_in_mem = in_mem_log;
 
 		t = time(NULL);
-		print_to_mem(DO_STR, "\n%s: ", cdevname ? cdevname : "UNKNOWN-DEV", NULL); 
-		print_to_mem(DO_STR, "fsck_hfs run at %s", ctime(&t), NULL);
+		print_to_mem(DO_STR, "\n%s: ", cdevname ? cdevname : "UNKNOWN-DEV", ap); 
+		print_to_mem(DO_STR, "fsck_hfs run at %s", ctime(&t), ap);
 
 		if (live_fsck && log_file) {
 		    pthread_cond_init(&mem_buf_cond, NULL);
@@ -659,7 +671,8 @@
 	LOG_PREFIX;				\
 	fprintf(log_file, fmt, str);		\
     } else { \
-	print_to_mem(DO_STR, fmt, str, NULL);	\
+	va_list ap; \
+	print_to_mem(DO_STR, fmt, str, ap);	\
     }
 
 
@@ -811,6 +824,19 @@
 #define kProgressToggle	"kern.progressmeterenable"
 #define	kProgress	"kern.progressmeter"
 
+#if LINUX
+void start_progress()
+{
+}
+
+void draw_progress(int pct)
+{
+}
+
+void end_progress()
+{
+}
+#else
 void
 start_progress(void)
 {
@@ -848,4 +874,4 @@
 		warn("sysctl(%s) failed", kProgressToggle);
 	}
 }
-
+#endif
diff -Naur a/include/bitstring.h b/include/bitstring.h
--- a/include/bitstring.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/bitstring.h	2011-11-19 12:13:50.000000000 +0100
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Paul Vixie.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)bitstring.h	8.1 (Berkeley) 7/19/93
+ */
+
+#ifndef _BITSTRING_H_
+#define	_BITSTRING_H_
+
+typedef	unsigned char bitstr_t;
+
+/* internal macros */
+				/* byte of the bitstring bit is in */
+#define	_bit_byte(bit) \
+	((bit) >> 3)
+
+				/* mask for the bit within its byte */
+#define	_bit_mask(bit) \
+	(1 << ((bit)&0x7))
+
+/* external macros */
+				/* bytes in a bitstring of nbits bits */
+#define	bitstr_size(nbits) \
+	((((nbits) - 1) >> 3) + 1)
+
+				/* allocate a bitstring */
+#define	bit_alloc(nbits) \
+	(bitstr_t *)calloc(1, \
+	    (unsigned int)bitstr_size(nbits) * sizeof(bitstr_t))
+
+				/* allocate a bitstring on the stack */
+#define	bit_decl(name, nbits) \
+	(name)[bitstr_size(nbits)]
+
+				/* is bit N of bitstring name set? */
+#define	bit_test(name, bit) \
+	((name)[_bit_byte(bit)] & _bit_mask(bit))
+
+				/* set bit N of bitstring name */
+#define	bit_set(name, bit) \
+	(name)[_bit_byte(bit)] |= _bit_mask(bit)
+
+				/* clear bit N of bitstring name */
+#define	bit_clear(name, bit) \
+	(name)[_bit_byte(bit)] &= ~_bit_mask(bit)
+
+				/* clear bits start ... stop in bitstring */
+#define	bit_nclear(name, start, stop) { \
+	register bitstr_t *_name = name; \
+	register int _start = start, _stop = stop; \
+	register int _startbyte = _bit_byte(_start); \
+	register int _stopbyte = _bit_byte(_stop); \
+	if (_startbyte == _stopbyte) { \
+		_name[_startbyte] &= ((0xff >> (8 - (_start&0x7))) | \
+				      (0xff << ((_stop&0x7) + 1))); \
+	} else { \
+		_name[_startbyte] &= 0xff >> (8 - (_start&0x7)); \
+		while (++_startbyte < _stopbyte) \
+			_name[_startbyte] = 0; \
+		_name[_stopbyte] &= 0xff << ((_stop&0x7) + 1); \
+	} \
+}
+
+				/* set bits start ... stop in bitstring */
+#define	bit_nset(name, start, stop) { \
+	register bitstr_t *_name = name; \
+	register int _start = start, _stop = stop; \
+	register int _startbyte = _bit_byte(_start); \
+	register int _stopbyte = _bit_byte(_stop); \
+	if (_startbyte == _stopbyte) { \
+		_name[_startbyte] |= ((0xff << (_start&0x7)) & \
+				    (0xff >> (7 - (_stop&0x7)))); \
+	} else { \
+		_name[_startbyte] |= 0xff << ((_start)&0x7); \
+		while (++_startbyte < _stopbyte) \
+	    		_name[_startbyte] = 0xff; \
+		_name[_stopbyte] |= 0xff >> (7 - (_stop&0x7)); \
+	} \
+}
+
+				/* find first bit clear in name */
+#define	bit_ffc(name, nbits, value) { \
+	register bitstr_t *_name = name; \
+	register int _byte, _nbits = nbits; \
+	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
+	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
+		if (_name[_byte] != 0xff) { \
+			_value = _byte << 3; \
+			for (_stopbyte = _name[_byte]; (_stopbyte&0x1); \
+			    ++_value, _stopbyte >>= 1); \
+			break; \
+		} \
+	*(value) = _value; \
+}
+
+				/* find first bit set in name */
+#define	bit_ffs(name, nbits, value) { \
+	register bitstr_t *_name = name; \
+	register int _byte, _nbits = nbits; \
+	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
+	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
+		if (_name[_byte]) { \
+			_value = _byte << 3; \
+			for (_stopbyte = _name[_byte]; !(_stopbyte&0x1); \
+			    ++_value, _stopbyte >>= 1); \
+			break; \
+		} \
+	*(value) = _value; \
+}
+
+#endif /* !_BITSTRING_H_ */
diff -Naur a/include/hfs/hfs_format.h b/include/hfs/hfs_format.h
--- a/include/hfs/hfs_format.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hfs/hfs_format.h	2011-11-19 14:21:29.000000000 +0100
@@ -0,0 +1,814 @@
+/*
+ * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ * 
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef __HFS_FORMAT__
+#define __HFS_FORMAT__
+
+#if LINUX
+#include "missing.h"
+#else
+#include <sys/appleapiopts.h>
+#endif
+#include <sys/types.h>
+
+/*
+ * hfs_format.c
+ *
+ * This file describes the on-disk format for HFS and HFS Plus volumes.
+ * The HFS Plus volume format is desciibed in detail in Apple Technote 1150.
+ *
+ * http://developer.apple.com/technotes/tn/tn1150.html
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* some on-disk hfs structures have 68K alignment (misaligned) */
+
+/* Signatures used to differentiate between HFS and HFS Plus volumes */
+enum {
+	kHFSSigWord		= 0x4244,	/* 'BD' in ASCII */
+	kHFSPlusSigWord		= 0x482B,	/* 'H+' in ASCII */
+	kHFSXSigWord		= 0x4858,	/* 'HX' in ASCII */
+
+	kHFSPlusVersion		= 0x0004,	/* 'H+' volumes are version 4 only */
+	kHFSXVersion		= 0x0005,	/* 'HX' volumes start with version 5 */
+
+	kHFSPlusMountVersion	= 0x31302E30,	/* '10.0' for Mac OS X */
+	kHFSJMountVersion	= 0x4846534a,	/* 'HFSJ' for journaled HFS+ on OS X */
+	kFSKMountVersion	= 0x46534b21	/* 'FSK!' for failed journal replay */
+};
+
+
+#ifdef __APPLE_API_PRIVATE
+/*
+ * Mac OS X has two special directories on HFS+ volumes for hardlinked files
+ * and hardlinked directories as well as for open-unlinked files.
+ *
+ * These directories and their contents are not exported from the filesystem
+ * under Mac OS X.
+ */
+#define HFSPLUSMETADATAFOLDER       "\xE2\x90\x80\xE2\x90\x80\xE2\x90\x80\xE2\x90\x80HFS+ Private Data"
+#define HFSPLUS_DIR_METADATA_FOLDER ".HFS+ Private Directory Data\xd"
+
+/*
+ * Files in the "HFS+ Private Data" folder have one of the following prefixes
+ * followed by a decimal number (no leading zeros) for the file ID.
+ *
+ * Note: Earlier version of Mac OS X used a 32 bit random number for the link
+ * ref number instead of the file id.
+ *
+ * e.g.  iNode7182000 and temp3296
+ */
+#define HFS_INODE_PREFIX	"iNode"
+#define HFS_DELETE_PREFIX	"temp"
+
+/*
+ * Files in the ".HFS+ Private Directory Data" folder have the following 
+ * prefix followed by a decimal number (no leading zeros) for the file ID.
+ *
+ * e.g. dir_555
+ */
+#define HFS_DIRINODE_PREFIX	"dir_"
+
+/*
+ * Hardlink inodes save the head of the link chain in
+ * an extended attribute named FIRST_LINK_XATTR_NAME.
+ * The attribute data is the decimal value in ASCII
+ * of the cnid for the first link in the chain.
+ *
+ * This extended attribute is private (i.e. its not
+ * exported in the getxattr/listxattr POSIX APIs).
+ */
+#define FIRST_LINK_XATTR_NAME	"com.apple.system.hfs.firstlink"
+#define FIRST_LINK_XATTR_REC_SIZE (sizeof(HFSPlusAttrData) - 2 + 12)
+
+/*
+ * The name space ID for generating an HFS volume UUID
+ *
+ * B3E20F39-F292-11D6-97A4-00306543ECAC
+ */
+#define HFS_UUID_NAMESPACE_ID  "\xB3\xE2\x0F\x39\xF2\x92\x11\xD6\x97\xA4\x00\x30\x65\x43\xEC\xAC"
+
+#endif /* __APPLE_API_PRIVATE */
+
+/*
+ * Indirect link files (hard links) have the following type/creator.
+ */
+enum {
+	kHardLinkFileType = 0x686C6E6B,  /* 'hlnk' */
+	kHFSPlusCreator   = 0x6866732B   /* 'hfs+' */
+};
+
+
+/*
+ *	File type and creator for symbolic links
+ */
+enum {
+      kSymLinkFileType  = 0x736C6E6B, /* 'slnk' */
+      kSymLinkCreator   = 0x72686170  /* 'rhap' */
+};
+
+
+#ifndef _HFSUNISTR255_DEFINED_
+#define _HFSUNISTR255_DEFINED_
+/* Unicode strings are used for HFS Plus file and folder names */
+struct HFSUniStr255 {
+	u_int16_t	length;		/* number of unicode characters */
+	u_int16_t	unicode[255];	/* unicode characters */
+} __attribute__((aligned(2), packed));
+typedef struct HFSUniStr255 HFSUniStr255;
+typedef const HFSUniStr255 *ConstHFSUniStr255Param;
+#endif /* _HFSUNISTR255_DEFINED_ */
+
+enum {
+	kHFSMaxVolumeNameChars		= 27,
+	kHFSMaxFileNameChars		= 31,
+	kHFSPlusMaxFileNameChars	= 255
+};
+
+
+/* Extent overflow file data structures */
+
+/* HFS Extent key */
+struct HFSExtentKey {
+	u_int8_t 	keyLength;	/* length of key, excluding this field */
+	u_int8_t 	forkType;	/* 0 = data fork, FF = resource fork */
+	u_int32_t 	fileID;		/* file ID */
+	u_int16_t 	startBlock;	/* first file allocation block number in this extent */
+} __attribute__((aligned(2), packed));
+typedef struct HFSExtentKey HFSExtentKey;
+
+/* HFS Plus Extent key */
+struct HFSPlusExtentKey {
+	u_int16_t 	keyLength;		/* length of key, excluding this field */
+	u_int8_t 	forkType;		/* 0 = data fork, FF = resource fork */
+	u_int8_t 	pad;			/* make the other fields align on 32-bit boundary */
+	u_int32_t 	fileID;			/* file ID */
+	u_int32_t 	startBlock;		/* first file allocation block number in this extent */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusExtentKey HFSPlusExtentKey;
+
+/* Number of extent descriptors per extent record */
+enum {
+	kHFSExtentDensity	= 3,
+	kHFSPlusExtentDensity	= 8
+};
+
+/* HFS extent descriptor */
+struct HFSExtentDescriptor {
+	u_int16_t 	startBlock;		/* first allocation block */
+	u_int16_t 	blockCount;		/* number of allocation blocks */
+} __attribute__((aligned(2), packed));
+typedef struct HFSExtentDescriptor HFSExtentDescriptor;
+
+/* HFS Plus extent descriptor */
+struct HFSPlusExtentDescriptor {
+	u_int32_t 	startBlock;		/* first allocation block */
+	u_int32_t 	blockCount;		/* number of allocation blocks */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusExtentDescriptor HFSPlusExtentDescriptor;
+
+/* HFS extent record */
+typedef HFSExtentDescriptor HFSExtentRecord[3];
+
+/* HFS Plus extent record */
+typedef HFSPlusExtentDescriptor HFSPlusExtentRecord[8];
+
+
+/* Finder information */
+struct FndrFileInfo {
+	u_int32_t 	fdType;		/* file type */
+	u_int32_t 	fdCreator;	/* file creator */
+	u_int16_t 	fdFlags;	/* Finder flags */
+	struct {
+	    int16_t	v;		/* file's location */
+	    int16_t	h;
+	} fdLocation;
+	int16_t 	opaque;
+} __attribute__((aligned(2), packed));
+typedef struct FndrFileInfo FndrFileInfo;
+
+struct FndrDirInfo {
+	struct {			/* folder's window rectangle */
+	    int16_t	top;
+	    int16_t	left;
+	    int16_t	bottom;
+	    int16_t	right;
+	} frRect;
+	unsigned short 	frFlags;	/* Finder flags */
+	struct {
+	    u_int16_t	v;		/* folder's location */
+	    u_int16_t	h;
+	} frLocation;
+	int16_t 	opaque;
+} __attribute__((aligned(2), packed));
+typedef struct FndrDirInfo FndrDirInfo;
+
+struct FndrOpaqueInfo {
+	int8_t opaque[16];
+} __attribute__((aligned(2), packed));
+typedef struct FndrOpaqueInfo FndrOpaqueInfo;
+
+struct FndrExtendedDirInfo {
+	u_int32_t point;
+	u_int32_t date_added;
+	u_int16_t extended_flags;
+	u_int16_t reserved3;
+	u_int32_t reserved4;
+} __attribute__((aligned(2), packed));
+
+struct FndrExtendedFileInfo {
+	u_int32_t reserved1;
+	u_int32_t date_added;
+	u_int16_t extended_flags;
+	u_int16_t reserved2;
+	u_int32_t reserved3;	
+} __attribute__((aligned(2), packed));
+
+/* HFS Plus Fork data info - 80 bytes */
+struct HFSPlusForkData {
+	u_int64_t 		logicalSize;	/* fork's logical size in bytes */
+	u_int32_t 		clumpSize;	/* fork's clump size in bytes */
+	u_int32_t 		totalBlocks;	/* total blocks used by this fork */
+	HFSPlusExtentRecord 	extents;	/* initial set of extents */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusForkData HFSPlusForkData;
+
+
+/* Mac OS X has 16 bytes worth of "BSD" info.
+ *
+ * Note:  Mac OS 9 implementations and applications
+ * should preserve, but not change, this information.
+ */
+struct HFSPlusBSDInfo {
+	u_int32_t 	ownerID;	/* user-id of owner or hard link chain previous link */
+	u_int32_t 	groupID;	/* group-id of owner or hard link chain next link */
+	u_int8_t 	adminFlags;	/* super-user changeable flags */
+	u_int8_t 	ownerFlags;	/* owner changeable flags */
+	u_int16_t 	fileMode;	/* file type and permission bits */
+	union {
+	    u_int32_t	iNodeNum;	/* indirect node number (hard links only) */
+	    u_int32_t	linkCount;	/* links that refer to this indirect node */
+	    u_int32_t	rawDevice;	/* special file device (FBLK and FCHR only) */
+	} special;
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusBSDInfo HFSPlusBSDInfo;
+
+/*
+ * Hardlink "links" resolve to an inode
+ * and the actual uid/gid comes from that
+ * inode.
+ *
+ * We repurpose the links's uid/gid fields
+ * for the hardlink link chain. The chain
+ * consists of a doubly linked list of file
+ * ids.
+ */
+ 
+#define hl_firstLinkID     reserved1         /* Valid only if HasLinkChain flag is set (indirect nodes only) */
+
+#define hl_prevLinkID      bsdInfo.ownerID   /* Valid only if HasLinkChain flag is set */
+#define hl_nextLinkID      bsdInfo.groupID   /* Valid only if HasLinkChain flag is set */
+
+#define hl_linkReference   bsdInfo.special.iNodeNum
+#define hl_linkCount       bsdInfo.special.linkCount
+
+
+/* Catalog file data structures */
+
+enum {
+	kHFSRootParentID		= 1,	/* Parent ID of the root folder */
+	kHFSRootFolderID		= 2,	/* Folder ID of the root folder */
+	kHFSExtentsFileID		= 3,	/* File ID of the extents file */
+	kHFSCatalogFileID		= 4,	/* File ID of the catalog file */
+	kHFSBadBlockFileID		= 5,	/* File ID of the bad allocation block file */
+	kHFSAllocationFileID		= 6,	/* File ID of the allocation file (HFS Plus only) */
+	kHFSStartupFileID		= 7,	/* File ID of the startup file (HFS Plus only) */
+	kHFSAttributesFileID		= 8,	/* File ID of the attribute file (HFS Plus only) */
+	kHFSAttributeDataFileID         = 13,	/* Used in Mac OS X runtime for extent based attributes */
+	                                        /* kHFSAttributeDataFileID is never stored on disk. */
+	kHFSRepairCatalogFileID		= 14,	/* Used when rebuilding Catalog B-tree */
+	kHFSBogusExtentFileID		= 15,	/* Used for exchanging extents in extents file */
+	kHFSFirstUserCatalogNodeID	= 16
+};
+
+/* HFS catalog key */
+struct HFSCatalogKey {
+	u_int8_t 	keyLength;		/* key length (in bytes) */
+	u_int8_t 	reserved;		/* reserved (set to zero) */
+	u_int32_t 	parentID;		/* parent folder ID */
+	u_int8_t 	nodeName[kHFSMaxFileNameChars + 1]; /* catalog node name */
+} __attribute__((aligned(2), packed));
+typedef struct HFSCatalogKey HFSCatalogKey;
+
+/* HFS Plus catalog key */
+struct HFSPlusCatalogKey {
+	u_int16_t 		keyLength;	/* key length (in bytes) */
+	u_int32_t 		parentID;	/* parent folder ID */
+	HFSUniStr255 		nodeName;	/* catalog node name */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusCatalogKey HFSPlusCatalogKey;
+
+/* Catalog record types */
+enum {
+	/* HFS Catalog Records */
+	kHFSFolderRecord		= 0x0100,	/* Folder record */
+	kHFSFileRecord			= 0x0200,	/* File record */
+	kHFSFolderThreadRecord		= 0x0300,	/* Folder thread record */
+	kHFSFileThreadRecord		= 0x0400,	/* File thread record */
+
+	/* HFS Plus Catalog Records */
+	kHFSPlusFolderRecord		= 1,		/* Folder record */
+	kHFSPlusFileRecord		= 2,		/* File record */
+	kHFSPlusFolderThreadRecord	= 3,		/* Folder thread record */
+	kHFSPlusFileThreadRecord	= 4		/* File thread record */
+};
+
+
+/* Catalog file record flags */
+enum {
+	kHFSFileLockedBit	= 0x0000,	/* file is locked and cannot be written to */
+	kHFSFileLockedMask	= 0x0001,
+
+	kHFSThreadExistsBit	= 0x0001,	/* a file thread record exists for this file */
+	kHFSThreadExistsMask	= 0x0002,
+
+	kHFSHasAttributesBit	= 0x0002,	/* object has extended attributes */
+	kHFSHasAttributesMask	= 0x0004,
+
+	kHFSHasSecurityBit	= 0x0003,	/* object has security data (ACLs) */
+	kHFSHasSecurityMask	= 0x0008,
+
+	kHFSHasFolderCountBit	= 0x0004,	/* only for HFSX, folder maintains a separate sub-folder count */
+	kHFSHasFolderCountMask	= 0x0010,	/* (sum of folder records and directory hard links) */
+
+	kHFSHasLinkChainBit	= 0x0005,	/* has hardlink chain (inode or link) */
+	kHFSHasLinkChainMask	= 0x0020,
+
+	kHFSHasChildLinkBit	= 0x0006,	/* folder has a child that's a dir link */
+	kHFSHasChildLinkMask	= 0x0040,
+
+	kHFSHasDateAddedBit = 0x0007,	/* File/Folder has the date-added stored in the finder info. */
+	kHFSHasDateAddedMask = 0x0080 
+
+};
+
+
+/* HFS catalog folder record - 70 bytes */
+struct HFSCatalogFolder {
+	int16_t 		recordType;		/* == kHFSFolderRecord */
+	u_int16_t 		flags;			/* folder flags */
+	u_int16_t 		valence;		/* folder valence */
+	u_int32_t		folderID;		/* folder ID */
+	u_int32_t 		createDate;		/* date and time of creation */
+	u_int32_t 		modifyDate;		/* date and time of last modification */
+	u_int32_t 		backupDate;		/* date and time of last backup */
+	FndrDirInfo 		userInfo;		/* Finder information */
+	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
+	u_int32_t 		reserved[4];		/* reserved - initialized as zero */
+} __attribute__((aligned(2), packed));
+typedef struct HFSCatalogFolder HFSCatalogFolder;
+
+/* HFS Plus catalog folder record - 88 bytes */
+struct HFSPlusCatalogFolder {
+	int16_t 		recordType;		/* == kHFSPlusFolderRecord */
+	u_int16_t 		flags;			/* file flags */
+	u_int32_t 		valence;		/* folder's item count */
+	u_int32_t 		folderID;		/* folder ID */
+	u_int32_t 		createDate;		/* date and time of creation */
+	u_int32_t 		contentModDate;		/* date and time of last content modification */
+	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
+	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
+	u_int32_t 		backupDate;		/* date and time of last backup */
+	HFSPlusBSDInfo		bsdInfo;		/* permissions (for MacOS X) */
+	FndrDirInfo 		userInfo;		/* Finder information */
+	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
+	u_int32_t 		textEncoding;		/* hint for name conversions */
+	u_int32_t 		folderCount;		/* number of enclosed folders, active when HasFolderCount is set */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusCatalogFolder HFSPlusCatalogFolder;
+
+/* HFS catalog file record - 102 bytes */
+struct HFSCatalogFile {
+	int16_t 		recordType;		/* == kHFSFileRecord */
+	u_int8_t 		flags;			/* file flags */
+	int8_t 			fileType;		/* file type (unused ?) */
+	FndrFileInfo 		userInfo;		/* Finder information */
+	u_int32_t 		fileID;			/* file ID */
+	u_int16_t 		dataStartBlock;		/* not used - set to zero */
+	int32_t 		dataLogicalSize;	/* logical EOF of data fork */
+	int32_t 		dataPhysicalSize;	/* physical EOF of data fork */
+	u_int16_t		rsrcStartBlock;		/* not used - set to zero */
+	int32_t			rsrcLogicalSize;	/* logical EOF of resource fork */
+	int32_t			rsrcPhysicalSize;	/* physical EOF of resource fork */
+	u_int32_t		createDate;		/* date and time of creation */
+	u_int32_t		modifyDate;		/* date and time of last modification */
+	u_int32_t		backupDate;		/* date and time of last backup */
+	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
+	u_int16_t		clumpSize;		/* file clump size (not used) */
+	HFSExtentRecord		dataExtents;		/* first data fork extent record */
+	HFSExtentRecord		rsrcExtents;		/* first resource fork extent record */
+	u_int32_t		reserved;		/* reserved - initialized as zero */
+} __attribute__((aligned(2), packed));
+typedef struct HFSCatalogFile HFSCatalogFile;
+
+/* HFS Plus catalog file record - 248 bytes */
+struct HFSPlusCatalogFile {
+	int16_t 		recordType;		/* == kHFSPlusFileRecord */
+	u_int16_t 		flags;			/* file flags */
+	u_int32_t 		reserved1;		/* reserved - initialized as zero */
+	u_int32_t 		fileID;			/* file ID */
+	u_int32_t 		createDate;		/* date and time of creation */
+	u_int32_t 		contentModDate;		/* date and time of last content modification */
+	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
+	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
+	u_int32_t 		backupDate;		/* date and time of last backup */
+	HFSPlusBSDInfo 		bsdInfo;		/* permissions (for MacOS X) */
+	FndrFileInfo 		userInfo;		/* Finder information */
+	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
+	u_int32_t 		textEncoding;		/* hint for name conversions */
+	u_int32_t 		reserved2;		/* reserved - initialized as zero */
+
+	/* Note: these start on double long (64 bit) boundary */
+	HFSPlusForkData 	dataFork;		/* size and block data for data fork */
+	HFSPlusForkData 	resourceFork;		/* size and block data for resource fork */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusCatalogFile HFSPlusCatalogFile;
+
+/* HFS catalog thread record - 46 bytes */
+struct HFSCatalogThread {
+	int16_t 	recordType;		/* == kHFSFolderThreadRecord or kHFSFileThreadRecord */
+	int32_t 	reserved[2];		/* reserved - initialized as zero */
+	u_int32_t 	parentID;		/* parent ID for this catalog node */
+	u_int8_t 	nodeName[kHFSMaxFileNameChars + 1]; /* name of this catalog node */
+} __attribute__((aligned(2), packed));
+typedef struct HFSCatalogThread HFSCatalogThread;
+
+/* HFS Plus catalog thread record -- 264 bytes */
+struct HFSPlusCatalogThread {
+	int16_t 	recordType;		/* == kHFSPlusFolderThreadRecord or kHFSPlusFileThreadRecord */
+	int16_t 	reserved;		/* reserved - initialized as zero */
+	u_int32_t 	parentID;		/* parent ID for this catalog node */
+	HFSUniStr255 	nodeName;		/* name of this catalog node (variable length) */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusCatalogThread HFSPlusCatalogThread;
+
+#ifdef __APPLE_API_UNSTABLE
+/*
+  	These are the types of records in the attribute B-tree.  The values were
+  	chosen so that they wouldn't conflict with the catalog record types.
+*/
+enum {
+	kHFSPlusAttrInlineData	= 0x10,   /* attributes whose data fits in a b-tree node */
+	kHFSPlusAttrForkData	= 0x20,   /* extent based attributes (data lives in extents) */
+	kHFSPlusAttrExtents	= 0x30    /* overflow extents for large attributes */
+};
+
+
+/*
+  	HFSPlusAttrForkData
+  	For larger attributes, whose value is stored in allocation blocks.
+  	If the attribute has more than 8 extents, there will be additional
+  	records (of type HFSPlusAttrExtents) for this attribute.
+*/
+struct HFSPlusAttrForkData {
+	u_int32_t 	recordType;		/* == kHFSPlusAttrForkData*/
+	u_int32_t 	reserved;
+	HFSPlusForkData theFork;		/* size and first extents of value*/
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusAttrForkData HFSPlusAttrForkData;
+
+/*
+  	HFSPlusAttrExtents
+  	This record contains information about overflow extents for large,
+  	fragmented attributes.
+*/
+struct HFSPlusAttrExtents {
+	u_int32_t 		recordType;	/* == kHFSPlusAttrExtents*/
+	u_int32_t 		reserved;
+	HFSPlusExtentRecord	extents;	/* additional extents*/
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusAttrExtents HFSPlusAttrExtents;
+
+/*
+ * Atrributes B-tree Data Record
+ *
+ * For small attributes, whose entire value is stored
+ * within a single B-tree record.
+ */
+struct HFSPlusAttrData {
+	u_int32_t    recordType;   /* == kHFSPlusAttrInlineData */
+	u_int32_t    reserved[2];
+	u_int32_t    attrSize;     /* size of attribute data in bytes */
+	u_int8_t     attrData[2];  /* variable length */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusAttrData HFSPlusAttrData;
+
+
+/* HFSPlusAttrInlineData is obsolete use HFSPlusAttrData instead */
+struct HFSPlusAttrInlineData {
+	u_int32_t 	recordType;
+	u_int32_t 	reserved;
+	u_int32_t 	logicalSize;
+	u_int8_t 	userData[2];
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusAttrInlineData HFSPlusAttrInlineData;
+
+
+/*	A generic Attribute Record*/
+union HFSPlusAttrRecord {
+	u_int32_t 		recordType;
+	HFSPlusAttrInlineData 	inlineData;   /* NOT USED */
+	HFSPlusAttrData 	attrData;
+	HFSPlusAttrForkData 	forkData;
+	HFSPlusAttrExtents 	overflowExtents;
+};
+typedef union HFSPlusAttrRecord HFSPlusAttrRecord;
+
+/* Attribute key */
+enum { kHFSMaxAttrNameLen = 127 };
+struct HFSPlusAttrKey {
+	u_int16_t     keyLength;       /* key length (in bytes) */
+	u_int16_t     pad;	       /* set to zero */
+	u_int32_t     fileID;          /* file associated with attribute */
+	u_int32_t     startBlock;      /* first allocation block number for extents */
+	u_int16_t     attrNameLen;     /* number of unicode characters */
+	u_int16_t     attrName[kHFSMaxAttrNameLen];   /* attribute name (Unicode) */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusAttrKey HFSPlusAttrKey;
+
+#define kHFSPlusAttrKeyMaximumLength   (sizeof(HFSPlusAttrKey) - sizeof(u_int16_t))
+#define kHFSPlusAttrKeyMinimumLength   (kHFSPlusAttrKeyMaximumLength - kHFSMaxAttrNameLen*sizeof(u_int16_t))
+
+#endif /* __APPLE_API_UNSTABLE */
+
+
+/* Key and node lengths */
+enum {
+	kHFSPlusExtentKeyMaximumLength = sizeof(HFSPlusExtentKey) - sizeof(u_int16_t),
+	kHFSExtentKeyMaximumLength	= sizeof(HFSExtentKey) - sizeof(u_int8_t),
+	kHFSPlusCatalogKeyMaximumLength = sizeof(HFSPlusCatalogKey) - sizeof(u_int16_t),
+	kHFSPlusCatalogKeyMinimumLength = kHFSPlusCatalogKeyMaximumLength - sizeof(HFSUniStr255) + sizeof(u_int16_t),
+	kHFSCatalogKeyMaximumLength	= sizeof(HFSCatalogKey) - sizeof(u_int8_t),
+	kHFSCatalogKeyMinimumLength	= kHFSCatalogKeyMaximumLength - (kHFSMaxFileNameChars + 1) + sizeof(u_int8_t),
+	kHFSPlusCatalogMinNodeSize	= 4096,
+	kHFSPlusExtentMinNodeSize	= 512,
+	kHFSPlusAttrMinNodeSize		= 4096
+};
+
+/* HFS and HFS Plus volume attribute bits */
+enum {
+	/* Bits 0-6 are reserved (always cleared by MountVol call) */
+	kHFSVolumeHardwareLockBit	= 7,		/* volume is locked by hardware */
+	kHFSVolumeUnmountedBit		= 8,		/* volume was successfully unmounted */
+	kHFSVolumeSparedBlocksBit	= 9,		/* volume has bad blocks spared */
+	kHFSVolumeNoCacheRequiredBit = 10,		/* don't cache volume blocks (i.e. RAM or ROM disk) */
+	kHFSBootVolumeInconsistentBit = 11,		/* boot volume is inconsistent (System 7.6 and later) */
+	kHFSCatalogNodeIDsReusedBit = 12,
+	kHFSVolumeJournaledBit = 13,			/* this volume has a journal on it */
+	kHFSVolumeInconsistentBit = 14,			/* serious inconsistencies detected at runtime */
+	kHFSVolumeSoftwareLockBit	= 15,		/* volume is locked by software */
+	/*
+	 * HFS only has 16 bits of attributes in the MDB, but HFS Plus has 32 bits.
+	 * Therefore, bits 16-31 can only be used on HFS Plus.
+	 */
+	kHFSUnusedNodeFixBit = 31,				/* Unused nodes in the Catalog B-tree have been zero-filled.  See Radar #6947811. */
+	kHFSContentProtectionBit = 30,			/* Volume has per-file content protection */
+
+	kHFSVolumeHardwareLockMask	= 1 << kHFSVolumeHardwareLockBit,
+	kHFSVolumeUnmountedMask		= 1 << kHFSVolumeUnmountedBit,
+	kHFSVolumeSparedBlocksMask	= 1 << kHFSVolumeSparedBlocksBit,
+	kHFSVolumeNoCacheRequiredMask = 1 << kHFSVolumeNoCacheRequiredBit,
+	kHFSBootVolumeInconsistentMask = 1 << kHFSBootVolumeInconsistentBit,
+	kHFSCatalogNodeIDsReusedMask = 1 << kHFSCatalogNodeIDsReusedBit,
+	kHFSVolumeJournaledMask	= 1 << kHFSVolumeJournaledBit,
+	kHFSVolumeInconsistentMask = 1 << kHFSVolumeInconsistentBit,
+	kHFSVolumeSoftwareLockMask	= 1 << kHFSVolumeSoftwareLockBit,
+	kHFSUnusedNodeFixMask = 1 << kHFSUnusedNodeFixBit,
+	kHFSContentProtectionMask = 1 << kHFSContentProtectionBit,
+	kHFSMDBAttributesMask		= 0x8380
+};
+
+enum {
+	kHFSUnusedNodesFixDate = 0xc5ef2480		/* March 25, 2009 */
+};
+
+/* HFS Master Directory Block - 162 bytes */
+/* Stored at sector #2 (3rd sector) and second-to-last sector. */
+struct HFSMasterDirectoryBlock {
+	u_int16_t 		drSigWord;	/* == kHFSSigWord */
+	u_int32_t 		drCrDate;	/* date and time of volume creation */
+	u_int32_t 		drLsMod;	/* date and time of last modification */
+	u_int16_t 		drAtrb;		/* volume attributes */
+	u_int16_t 		drNmFls;	/* number of files in root folder */
+	u_int16_t 		drVBMSt;	/* first block of volume bitmap */
+	u_int16_t 		drAllocPtr;	/* start of next allocation search */
+	u_int16_t 		drNmAlBlks;	/* number of allocation blocks in volume */
+	u_int32_t 		drAlBlkSiz;	/* size (in bytes) of allocation blocks */
+	u_int32_t 		drClpSiz;	/* default clump size */
+	u_int16_t 		drAlBlSt;	/* first allocation block in volume */
+	u_int32_t 		drNxtCNID;	/* next unused catalog node ID */
+	u_int16_t 		drFreeBks;	/* number of unused allocation blocks */
+	u_int8_t 		drVN[kHFSMaxVolumeNameChars + 1];  /* volume name */
+	u_int32_t 		drVolBkUp;	/* date and time of last backup */
+	u_int16_t 		drVSeqNum;	/* volume backup sequence number */
+	u_int32_t 		drWrCnt;	/* volume write count */
+	u_int32_t 		drXTClpSiz;	/* clump size for extents overflow file */
+	u_int32_t 		drCTClpSiz;	/* clump size for catalog file */
+	u_int16_t 		drNmRtDirs;	/* number of directories in root folder */
+	u_int32_t 		drFilCnt;	/* number of files in volume */
+	u_int32_t 		drDirCnt;	/* number of directories in volume */
+	u_int32_t 		drFndrInfo[8];	/* information used by the Finder */
+	u_int16_t 		drEmbedSigWord;	/* embedded volume signature (formerly drVCSize) */
+	HFSExtentDescriptor	drEmbedExtent;	/* embedded volume location and size (formerly drVBMCSize and drCtlCSize) */
+	u_int32_t		drXTFlSize;	/* size of extents overflow file */
+	HFSExtentRecord		drXTExtRec;	/* extent record for extents overflow file */
+	u_int32_t 		drCTFlSize;	/* size of catalog file */
+	HFSExtentRecord 	drCTExtRec;	/* extent record for catalog file */
+} __attribute__((aligned(2), packed));
+typedef struct HFSMasterDirectoryBlock	HFSMasterDirectoryBlock;
+
+
+#ifdef __APPLE_API_UNSTABLE
+#define SET_HFS_TEXT_ENCODING(hint)  \
+	(0x656e6300 | ((hint) & 0xff))
+#define GET_HFS_TEXT_ENCODING(hint)  \
+	(((hint) & 0xffffff00) == 0x656e6300 ? (hint) & 0x000000ff : 0xffffffffU)
+#endif /* __APPLE_API_UNSTABLE */
+
+
+/* HFS Plus Volume Header - 512 bytes */
+/* Stored at sector #2 (3rd sector) and second-to-last sector. */
+struct HFSPlusVolumeHeader {
+	u_int16_t 	signature;		/* == kHFSPlusSigWord */
+	u_int16_t 	version;		/* == kHFSPlusVersion */
+	u_int32_t 	attributes;		/* volume attributes */
+	u_int32_t 	lastMountedVersion;	/* implementation version which last mounted volume */
+	u_int32_t 	journalInfoBlock;	/* block addr of journal info (if volume is journaled, zero otherwise) */
+
+	u_int32_t 	createDate;		/* date and time of volume creation */
+	u_int32_t 	modifyDate;		/* date and time of last modification */
+	u_int32_t 	backupDate;		/* date and time of last backup */
+	u_int32_t 	checkedDate;		/* date and time of last disk check */
+
+	u_int32_t 	fileCount;		/* number of files in volume */
+	u_int32_t 	folderCount;		/* number of directories in volume */
+
+	u_int32_t 	blockSize;		/* size (in bytes) of allocation blocks */
+	u_int32_t 	totalBlocks;		/* number of allocation blocks in volume (includes this header and VBM*/
+	u_int32_t 	freeBlocks;		/* number of unused allocation blocks */
+
+	u_int32_t 	nextAllocation;		/* start of next allocation search */
+	u_int32_t 	rsrcClumpSize;		/* default resource fork clump size */
+	u_int32_t 	dataClumpSize;		/* default data fork clump size */
+	u_int32_t 	nextCatalogID;		/* next unused catalog node ID */
+
+	u_int32_t 	writeCount;		/* volume write count */
+	u_int64_t 	encodingsBitmap;	/* which encodings have been use  on this volume */
+
+	u_int8_t 	finderInfo[32];		/* information used by the Finder */
+
+	HFSPlusForkData	 allocationFile;	/* allocation bitmap file */
+	HFSPlusForkData  extentsFile;		/* extents B-tree file */
+	HFSPlusForkData  catalogFile;		/* catalog B-tree file */
+	HFSPlusForkData  attributesFile;	/* extended attributes B-tree file */
+	HFSPlusForkData	 startupFile;		/* boot file (secondary loader) */
+} __attribute__((aligned(2), packed));
+typedef struct HFSPlusVolumeHeader HFSPlusVolumeHeader;
+
+
+/* B-tree structures */
+
+enum BTreeKeyLimits{
+	kMaxKeyLength	= 520
+};
+
+union BTreeKey{
+	u_int8_t	length8;
+	u_int16_t	length16;
+	u_int8_t	rawData [kMaxKeyLength+2];
+};
+typedef union BTreeKey BTreeKey;
+
+/* BTNodeDescriptor -- Every B-tree node starts with these fields. */
+struct BTNodeDescriptor {
+	u_int32_t	fLink;			/* next node at this level*/
+	u_int32_t 	bLink;			/* previous node at this level*/
+	int8_t 		kind;			/* kind of node (leaf, index, header, map)*/
+	u_int8_t 	height;			/* zero for header, map; child is one more than parent*/
+	u_int16_t 	numRecords;		/* number of records in this node*/
+	u_int16_t 	reserved;		/* reserved - initialized as zero */
+} __attribute__((aligned(2), packed));
+typedef struct BTNodeDescriptor BTNodeDescriptor;
+
+/* Constants for BTNodeDescriptor kind */
+enum {
+	kBTLeafNode	= -1,
+	kBTIndexNode	= 0,
+	kBTHeaderNode	= 1,
+	kBTMapNode	= 2
+};
+
+/* BTHeaderRec -- The first record of a B-tree header node */
+struct BTHeaderRec {
+	u_int16_t	treeDepth;		/* maximum height (usually leaf nodes) */
+	u_int32_t 	rootNode;		/* node number of root node */
+	u_int32_t 	leafRecords;		/* number of leaf records in all leaf nodes */
+	u_int32_t 	firstLeafNode;		/* node number of first leaf node */
+	u_int32_t 	lastLeafNode;		/* node number of last leaf node */
+	u_int16_t 	nodeSize;		/* size of a node, in bytes */
+	u_int16_t 	maxKeyLength;		/* reserved */
+	u_int32_t 	totalNodes;		/* total number of nodes in tree */
+	u_int32_t 	freeNodes;		/* number of unused (free) nodes in tree */
+	u_int16_t 	reserved1;		/* unused */
+	u_int32_t 	clumpSize;		/* reserved */
+	u_int8_t 	btreeType;		/* reserved */
+	u_int8_t 	keyCompareType;		/* Key string Comparison Type */
+	u_int32_t 	attributes;		/* persistent attributes about the tree */
+	u_int32_t 	reserved3[16];		/* reserved */
+} __attribute__((aligned(2), packed));
+typedef struct BTHeaderRec BTHeaderRec;
+
+/* Constants for BTHeaderRec attributes */
+enum {
+	kBTBadCloseMask		 = 0x00000001,	/* reserved */
+	kBTBigKeysMask		 = 0x00000002,	/* key length field is 16 bits */
+	kBTVariableIndexKeysMask = 0x00000004	/* keys in index nodes are variable length */
+};
+
+
+/* Catalog Key Name Comparison Type */
+enum {
+	kHFSCaseFolding   = 0xCF,  /* case folding (case-insensitive) */
+	kHFSBinaryCompare = 0xBC  /* binary compare (case-sensitive) */
+};
+
+#include <uuid/uuid.h>
+
+/* JournalInfoBlock - Structure that describes where our journal lives */
+
+// the original size of the reserved field in the JournalInfoBlock was
+// 32*sizeof(u_int32_t).  To keep the total size of the structure the 
+// same we subtract the size of new fields (currently: ext_jnl_uuid and
+// machine_uuid).  If you add additional fields, place them before the
+// reserved field and subtract their size in this macro.
+//
+#define JIB_RESERVED_SIZE  ((32*sizeof(u_int32_t)) - sizeof(uuid_string_t) - 48)
+
+struct JournalInfoBlock {
+	u_int32_t	flags;
+    	u_int32_t       device_signature[8];  // signature used to locate our device.
+	u_int64_t       offset;               // byte offset to the journal on the device
+	u_int64_t       size;                 // size in bytes of the journal
+	uuid_string_t   ext_jnl_uuid;
+	char            machine_serial_num[48];
+	char    	reserved[JIB_RESERVED_SIZE];
+} __attribute__((aligned(2), packed));
+typedef struct JournalInfoBlock JournalInfoBlock;
+
+enum {
+    kJIJournalInFSMask          = 0x00000001,
+    kJIJournalOnOtherDeviceMask = 0x00000002,
+    kJIJournalNeedInitMask      = 0x00000004
+};
+
+//
+// This the content type uuid for "external journal" GPT 
+// partitions.  Each instance of a partition also has a
+// uuid that uniquely identifies that instance.
+//
+#define EXTJNL_CONTENT_TYPE_UUID "4A6F7572-6E61-11AA-AA11-00306543ECAC"
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HFS_FORMAT__ */
diff -Naur a/include/hfs/hfs_mount.h b/include/hfs/hfs_mount.h
--- a/include/hfs/hfs_mount.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hfs/hfs_mount.h	2011-11-19 12:13:50.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+ * Copyright (c) 1997-2002 Apple Computer, Inc. All Rights Reserved
+ *
+ */
+
+#ifndef _HFS_MOUNT_H_
+#define _HFS_MOUNT_H_
+
+#include <sys/appleapiopts.h>
+
+#include <sys/mount.h>
+#include <sys/time.h>
+
+/*
+ * Arguments to mount HFS-based filesystems
+ */
+
+#define OVERRIDE_UNKNOWN_PERMISSIONS 0
+
+#define UNKNOWNUID ((uid_t)99)
+#define UNKNOWNGID ((gid_t)99)
+#define UNKNOWNPERMISSIONS (S_IRWXU | S_IROTH | S_IXOTH)		/* 705 */
+
+#ifdef __APPLE_API_UNSTABLE
+struct hfs_mount_args {
+#ifndef KERNEL
+	char	*fspec;			/* block special device to mount */
+#endif
+	uid_t	hfs_uid;		/* uid that owns hfs files (standard HFS only) */
+	gid_t	hfs_gid;		/* gid that owns hfs files (standard HFS only) */
+	mode_t	hfs_mask;		/* mask to be applied for hfs perms  (standard HFS only) */
+	u_int32_t hfs_encoding;		/* encoding for this volume (standard HFS only) */
+	struct	timezone hfs_timezone;	/* user time zone info (standard HFS only) */
+	int		flags;			/* mounting flags, see below */
+	int     journal_tbuffer_size;   /* size in bytes of the journal transaction buffer */
+	int		journal_flags;          /* flags to pass to journal_open/create */
+	int		journal_disable;        /* don't use journaling (potentially dangerous) */
+};
+
+#define HFSFSMNT_NOXONFILES	0x1	/* disable execute permissions for files */
+#define HFSFSMNT_WRAPPER	0x2	/* mount HFS wrapper (if it exists) */
+#define HFSFSMNT_EXTENDED_ARGS  0x4     /* indicates new fields after "flags" are valid */
+
+/*
+ * Sysctl values for HFS
+ */
+#define HFS_ENCODINGBIAS	1	    /* encoding matching CJK bias */
+#define HFS_EXTEND_FS		2
+#define HFS_ENCODINGHINT	3	    /* guess encoding for string */
+#define HFS_ENABLE_JOURNALING   0x082969
+#define HFS_DISABLE_JOURNALING  0x031272
+#define HFS_GET_JOURNAL_INFO    0x6a6e6c69
+#define HFS_SET_PKG_EXTENSIONS  0x121031
+
+#endif /* __APPLE_API_UNSTABLE */
+
+#endif /* ! _HFS_MOUNT_H_ */
diff -Naur a/include/missing.h b/include/missing.h
--- a/include/missing.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/missing.h	2011-11-19 14:51:01.000000000 +0100
@@ -0,0 +1,128 @@
+#ifndef _MISSING_H_
+#define _MISSING_H_
+
+#include <endian.h>
+#include <byteswap.h>
+#include <errno.h>
+#include <stdint.h>
+
+typedef	char uuid_string_t[37];
+#define __APPLE_API_PRIVATE
+#define __APPLE_API_UNSTABLE
+
+#define __diskdev_cmds_version "540.1-Linux"
+
+#define UF_IMMUTABLE    0x00000002
+#define XATTR_MAXNAMELEN 127
+#define MAXBSIZE		(256 * 4096)
+
+#ifndef true
+#define true			1
+#endif
+#ifndef false
+#define false			0
+#endif
+
+/* Mac types */
+
+/* 8 Bit */
+#ifndef UInt8
+#define UInt8			uint8_t
+#endif
+#ifndef u_int8_t
+#define u_int8_t		UInt8
+#endif
+#ifndef SInt8
+#define SInt8			int8_t
+#endif
+
+/* 16 Bit */
+#ifndef UInt16
+#define UInt16			uint16_t
+#endif
+#ifndef u_int16_t
+#define u_int16_t		UInt16
+#endif
+#ifndef SInt16
+#define SInt16			int16_t
+#endif
+
+/* 32 Bit */
+#ifndef UInt32
+#define UInt32			uint32_t
+#endif
+#ifndef u_int32_t
+#define u_int32_t		UInt32
+#endif
+#ifndef SInt32
+#define SInt32			int32_t
+#endif
+
+/* 64 Bit */
+#ifndef UInt64
+#define UInt64			uint64_t
+#endif
+#ifndef u_int64_t
+#define u_int64_t		UInt64
+#endif
+#ifndef SInt64
+#define SInt64			int64_t
+#endif
+
+#define UniChar			u_int16_t
+#define Boolean			u_int8_t
+
+#define UF_NODUMP	0x00000001
+
+/* syslimits.h */
+#define NAME_MAX	255
+
+/* Byteswap stuff */
+#define OSSwapHostLongToBig(x)		cpu_to_be64(x)
+#define OSSwapBigShortToHost(x) 	be16_to_cpu(x)
+#define OSSwapBigToHostInt16(x)		be16_to_cpu(x)
+#define OSSwapBigLongToHost(x)		be32_to_cpu(x)
+#define OSSwapBigToHostInt32(x)		be32_to_cpu(x)
+#define OSSwapBigLongLongToHost(x) 	be64_to_cpu(x)
+#define OSSwapBigToHostInt64(x)		be64_to_cpu(x)
+#define OSSwapHostToBigInt32(x)		cpu_to_be32(x)
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+/* Big Endian Swaps */
+#ifndef be16_to_cpu
+#define be16_to_cpu(x) bswap_16(x)
+#endif
+#ifndef be32_to_cpu
+#define be32_to_cpu(x) bswap_32(x)
+#endif
+#ifndef cpu_to_be32
+#define cpu_to_be32(x) bswap_32(x)
+#endif
+#ifndef be64_to_cpu
+#define be64_to_cpu(x) bswap_64(x)
+#endif
+#ifndef cpu_to_be64
+#define cpu_to_be64(x) bswap_64(x) 
+#endif
+#elif __BYTE_ORDER == __BIG_ENDIAN
+/* Big endian doesn't swap */
+#ifndef be16_to_cpu
+#define be16_to_cpu(x)	(x)
+#endif
+#ifndef be32_to_cpu
+#define be32_to_cpu(x)	(x)
+#endif
+#ifndef cpu_to_be32
+#define cpu_to_be32(x)	(x)
+#endif
+#ifndef be64_to_cpu
+#define be64_to_cpu(x)	(x)
+#endif
+#ifndef cpu_to_be64
+#define cpu_to_be64(x) 	(x)
+#endif
+#endif
+
+#define KAUTH_FILESEC_XATTR "com.apple.system.Security"
+
+#endif
diff -Naur a/include/sys/appleapiopts.h b/include/sys/appleapiopts.h
--- a/include/sys/appleapiopts.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/sys/appleapiopts.h	2011-11-19 12:13:50.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+#ifndef __SYS_APPLEAPIOPTS_H__
+#define __SYS_APPLEAPIOPTS_H__
+
+
+#ifndef __APPLE_API_STANDARD
+#define __APPLE_API_STANDARD
+#endif /* __APPLE_API_STANDARD */
+
+#ifndef __APPLE_API_STABLE
+#define __APPLE_API_STABLE
+#endif /* __APPLE_API_STABLE */
+
+#ifndef __APPLE_API_STRICT_CONFORMANCE
+
+#ifndef __APPLE_API_EVOLVING
+#define __APPLE_API_EVOLVING
+#endif /* __APPLE_API_EVOLVING */
+
+#ifndef __APPLE_API_UNSTABLE
+#define __APPLE_API_UNSTABLE
+#endif /* __APPLE_API_UNSTABLE */
+
+#ifndef __APPLE_API_PRIVATE
+#define __APPLE_API_PRIVATE
+#endif /* __APPLE_API_PRIVATE */
+
+#ifndef __APPLE_API_OBSOLETE
+#define __APPLE_API_OBSOLETE
+#endif /* __APPLE_API_OBSOLETE */
+
+#endif /* __APPLE_API_STRICT_CONFORMANCE */
+
+#endif /* __SYS_APPLEAPIOPTS_H__ */
+
diff -Naur a/Makefile b/Makefile
--- /dev/null		2010-11-06 00:38:11.000000000 +0100
+++ b/Makefile.lnx	2013-01-14 22:02:27.737418767 +0100
@@ -0,0 +1,11 @@
+VERSION=557.3-linux
+
+SUBDIRS := BlocksRunTime newfs_hfs.tproj fsck_hfs.tproj
+
+all clean:
+	for d in $(SUBDIRS); do $(MAKE) -C $$d -f Makefile.lnx $@; done
+ 
+dist: clean
+	-mkdir diskdev_cmds-$(VERSION)
+	cp -a $(SUBDIRS) Makefile include diskdev_cmds-$(VERSION)
+	tar zcf diskdev_cmds-$(VERSION).tar.gz diskdev_cmds-$(VERSION) 
diff -Naur a/newfs_hfs.tproj/hfs_endian.c b/newfs_hfs.tproj/hfs_endian.c
--- a/newfs_hfs.tproj/hfs_endian.c	2008-11-04 04:57:45.000000000 +0100
+++ b/newfs_hfs.tproj/hfs_endian.c	2012-02-01 18:17:19.000000000 +0100
@@ -31,7 +31,12 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#if LINUX
+#include "missing.h"
+#else
 #include <libkern/OSByteOrder.h>
+#endif
+
 #include <hfs/hfs_format.h>
 
 #include "hfs_endian.h"
diff -Naur a/newfs_hfs.tproj/hfs_endian.h b/newfs_hfs.tproj/hfs_endian.h
--- a/newfs_hfs.tproj/hfs_endian.h	2008-11-04 04:57:45.000000000 +0100
+++ b/newfs_hfs.tproj/hfs_endian.h	2012-02-01 18:17:19.000000000 +0100
@@ -30,7 +30,12 @@
  * volume format.
  */
 #include <hfs/hfs_format.h>
+#if LINUX
+#include <endian.h>
+#include <byteswap.h>
+#else
 #include <libkern/OSByteOrder.h>
+#endif
 
 /*********************/
 /* BIG ENDIAN Macros */
diff -Naur a/newfs_hfs.tproj/Makefile.lnx b/newfs_hfs.tproj/Makefile.lnx
--- a/newfs_hfs.tproj/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ b/newfs_hfs.tproj/Makefile.lnx	2011-11-19 12:45:18.000000000 +0100
@@ -0,0 +1,12 @@
+CFILES = hfs_endian.c makehfs.c newfs_hfs.c
+OFILES = $(CFILES:.c=.o)
+
+all: newfs_hfs
+
+newfs_hfs: $(OFILES)
+	${CC} ${CFLAGS} -o newfs_hfs ${OFILES} -lcrypto
+
+clean:
+	$(RM) newfs_hfs $(OFILES)
+
+.PHONY : FORCE clean
diff -Naur a/newfs_hfs.tproj/makehfs.c b/newfs_hfs.tproj/makehfs.c
--- a/newfs_hfs.tproj/makehfs.c	2011-03-15 22:45:15.000000000 +0100
+++ b/newfs_hfs.tproj/makehfs.c	2012-02-02 23:36:59.000000000 +0100
@@ -32,10 +32,16 @@
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/time.h>
+#if LINUX
+#include <time.h>
+#include "missing.h"
+#endif
 #include <sys/errno.h>
 #include <sys/stat.h>
 #include <sys/sysctl.h>
+#if !LINUX
 #include <sys/vmmeter.h>
+#endif
 
 #include <err.h>
 #include <errno.h>
@@ -46,7 +52,9 @@
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
+#if !LINUX
 #include <wipefs.h>
+#endif
 
 /*
  * CommonCrypto is meant to be a more stable API than OpenSSL.
@@ -54,6 +62,7 @@
  * with OpenSSL, so we don't have to change the code.
  */
 #define COMMON_DIGEST_FOR_OPENSSL
+#if !LINUX
 #include <CommonCrypto/CommonDigest.h>
 
 #include <libkern/OSByteOrder.h>
@@ -66,7 +75,9 @@
 #include <TargetConditionals.h>
 
 extern Boolean _CFStringGetFileSystemRepresentation(CFStringRef string, UInt8 *buffer, CFIndex maxBufLen);
-
+#else
+#include <openssl/sha.h>
+#endif
 
 #include <hfs/hfs_format.h>
 #include <hfs/hfs_mount.h>
@@ -125,7 +136,9 @@
 static void MarkBitInAllocationBuffer __P((HFSPlusVolumeHeader *header,
 		UInt32 allocationBlock, void* sectorBuffer, UInt64 *sector));
 
+#if !LINUX
 static UInt32 GetDefaultEncoding();
+#endif
 
 static UInt32 UTCToLocal __P((UInt32 utcTime));
 
@@ -152,6 +165,9 @@
 
 #define ROUNDUP(x, u)	(((x) % (u) == 0) ? (x) : ((x)/(u) + 1) * (u))
 
+#if LINUX
+#define ENCODING_TO_BIT(e)       (e)                    
+#else
 #if TARGET_OS_EMBEDDED
 #define ENCODING_TO_BIT(e)				 \
 	  ((e) < 48 ? (e) : 0)
@@ -161,6 +177,7 @@
           ((e) == kCFStringEncodingMacUkrainian ? 48 :   \
           ((e) == kCFStringEncodingMacFarsi ? 49 : 0)))
 #endif
+#endif
 
 
 #ifdef DEBUG_BUILD
@@ -172,6 +189,7 @@
 } __attribute__((aligned(2), packed)); 
 #endif
 
+#if !LINUX
 /*
  * wipefs() in -lutil knows about multiple filesystem formats.
  * This replaces the code:
@@ -193,7 +211,7 @@
 	wipefs_free(&handle);
 	return err;
 }
-
+#endif
 
 /*
  * make_hfsplus
@@ -217,13 +235,14 @@
 	UInt64			sector;
 	UInt64			bytesToZero;
 
+#if !LINUX
 	/* Use wipefs() API to clear old metadata from the device.
 	 * This should be done before we start writing anything on the 
 	 * device as wipefs will internally call ioctl(DKIOCDISCARD) on the 
 	 * entire device.
 	 */
 	(void) dowipefs(driveInfo->fd);
-
+#endif
 	/* --- Create an HFS Plus header:  */
 
 	header = (HFSPlusVolumeHeader*)malloc((size_t)kBytesPerSector);
@@ -454,7 +473,7 @@
 	}
 	hp->attributes = kHFSVolumeUnmountedMask | kHFSUnusedNodeFixMask;
 	if (defaults->flags & kMakeContentProtect) {
-		hp->attributes |= kHFSContentProtectionMask;	
+		hp->attributes |= kHFSContentProtectionMask;
 	}
 	hp->lastMountedVersion = kHFSPlusMountVersion;
 
@@ -893,7 +912,7 @@
 	WriteBuffer(driveInfo, startingSector, *bytesUsed, buffer);
 }
 
-#if !TARGET_OS_EMBEDDED
+#if !TARGET_OS_EMBEDDED && !LINUX
 static int
 get_dev_uuid(const char *disk_name, char *dev_uuid_str, int dev_uuid_len)
 {
@@ -951,7 +970,7 @@
     memset(buffer, 0xdb, driveInfo->physSectorSize);
     memset(jibp, 0, sizeof(JournalInfoBlock));
     
-#if !TARGET_OS_EMBEDDED
+#if !TARGET_OS_EMBEDDED && !LINUX
     if (dp->journalDevice) {
 	char uuid_str[64];
 
@@ -973,7 +992,7 @@
     } else {
 #endif
 	jibp->flags = kJIJournalInFSMask;
-#if !TARGET_OS_EMBEDDED
+#if !TARGET_OS_EMBEDDED && !LINUX
     }
 #endif
     jibp->flags  |= kJIJournalNeedInitMask;
@@ -1114,9 +1133,11 @@
 	UInt16					nodeSize;
 	SInt16					offset;
 	size_t					unicodeBytes;
+#if !LINUX
 	UInt8 canonicalName[256];
 	CFStringRef cfstr;
 	Boolean	cfOK;
+#endif
 	int index = 0;
 
 	nodeSize = dp->catalogNodeSize;
@@ -1136,7 +1157,9 @@
 	 * First record is always the root directory...
 	 */
 	ckp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
-	
+#if LINUX	
+	ConvertUTF8toUnicode(dp->volumeName, sizeof(ckp->nodeName.unicode), ckp->nodeName.unicode, &ckp->nodeName.length);
+#else
 	/* Use CFString functions to get a HFSPlus Canonical name */
 	cfstr = CFStringCreateWithCString(kCFAllocatorDefault, (char *)dp->volumeName, kCFStringEncodingUTF8);
 	cfOK = _CFStringGetFileSystemRepresentation(cfstr, canonicalName, sizeof(canonicalName));
@@ -1153,6 +1176,7 @@
 		      dp->volumeName, kDefaultVolumeNameStr);
 	}
 	CFRelease(cfstr);
+#endif
 	ckp->nodeName.length = SWAP_BE16 (ckp->nodeName.length);
 
 	unicodeBytes = sizeof(UniChar) * SWAP_BE16 (ckp->nodeName.length);
@@ -1164,9 +1188,12 @@
 	cdp = (HFSPlusCatalogFolder *)((UInt8 *)buffer + offset);
 	cdp->recordType		= SWAP_BE16 (kHFSPlusFolderRecord);
 	/* folder count is only supported on HFSX volumes */
+#if !LINUX
+	// FIXME
 	if (dp->flags & kMakeCaseSensitive) {
 		cdp->flags 		= SWAP_BE16 (kHFSHasFolderCountMask);
 	}
+#endif
 	cdp->valence        = SWAP_BE32 (dp->journaledHFS ? 2 : 0);
 	cdp->folderID		= SWAP_BE32 (kHFSRootFolderID);
 	cdp->createDate		= SWAP_BE32 (dp->createDate);
@@ -1528,6 +1555,7 @@
         return (localTime);
 }
 
+#if !LINUX
 #define __kCFUserEncodingFileName ("/.CFUserTextEncoding")
 
 static UInt32
@@ -1553,7 +1581,7 @@
     }
     return 0;
 }
-
+#endif
 
 static int
 ConvertUTF8toUnicode(const UInt8* source, size_t bufsize, UniChar* unibuf,
@@ -1620,6 +1648,9 @@
 static int
 getencodinghint(unsigned char *name)
 {
+#if LINUX
+	return(0);
+#else
         int mib[3];
         size_t buflen = sizeof(int);
         struct vfsconf vfc;
@@ -1637,7 +1668,8 @@
 	return (hint);
 error:
 	hint = GetDefaultEncoding();
-	return (hint);
+	return (0);
+#endif
 }
 
 
@@ -1648,12 +1680,14 @@
 	unsigned char digest[20];
 	time_t now;
 	clock_t uptime;
-	int mib[2];
-	int sysdata;
-	char sysctlstring[128];
 	size_t datalen;
 	double sysloadavg[3];
+#if !LINUX
+	int sysdata;
+	int mib[2];
+	char sysctlstring[128];
 	struct vmtotal sysvmtotal;
+#endif
 	
 	do {
 		/* Initialize the SHA-1 context for processing: */
@@ -1666,52 +1700,58 @@
 		SHA1_Update(&context, &uptime, sizeof(uptime));
 		
 		/* The kernel's boot time: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_BOOTTIME;
 		datalen = sizeof(sysdata);
 		sysctl(mib, 2, &sysdata, &datalen, NULL, 0);
 		SHA1_Update(&context, &sysdata, datalen);
-		
+#endif
 		/* The system's host id: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_HOSTID;
 		datalen = sizeof(sysdata);
 		sysctl(mib, 2, &sysdata, &datalen, NULL, 0);
 		SHA1_Update(&context, &sysdata, datalen);
-
+#endif
 		/* The system's host name: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_HOSTNAME;
 		datalen = sizeof(sysctlstring);
 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
 		SHA1_Update(&context, sysctlstring, datalen);
-
+#endif
 		/* The running kernel's OS release string: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_OSRELEASE;
 		datalen = sizeof(sysctlstring);
 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
 		SHA1_Update(&context, sysctlstring, datalen);
-
+#endif
 		/* The running kernel's version string: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_VERSION;
 		datalen = sizeof(sysctlstring);
 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
 		SHA1_Update(&context, sysctlstring, datalen);
-
+#endif
 		/* The system's load average: */
 		datalen = sizeof(sysloadavg);
 		getloadavg(sysloadavg, 3);
 		SHA1_Update(&context, &sysloadavg, datalen);
 
 		/* The system's VM statistics: */
+#if !LINUX
 		mib[0] = CTL_VM;
 		mib[1] = VM_METER;
 		datalen = sizeof(sysvmtotal);
 		sysctl(mib, 2, &sysvmtotal, &datalen, NULL, 0);
 		SHA1_Update(&context, &sysvmtotal, datalen);
-
+#endif
 		/* The current GMT (26 ASCII characters): */
 		time(&now);
 		strncpy(randomInputBuffer, asctime(gmtime(&now)), 26);	/* "Mon Mar 27 13:46:26 2000" */
--- a/newfs_hfs.tproj/newfs_hfs.c	2010-08-25 05:57:45.000000000 +0200
+++ b/newfs_hfs.tproj/newfs_hfs.c	2012-02-02 23:34:08.000000000 +0100
@@ -39,8 +39,13 @@
 #include <sys/mount.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#if LINUX
+#include <time.h>
+#endif
 
+#if !LINUX
 #include <IOKit/storage/IOMediaBSDClient.h>
+#endif
 
 #include <hfs/hfs_format.h>
 #include "newfs_hfs.h"
@@ -178,8 +183,10 @@
 	extern char *optarg;
 	extern int optind;
 	int ch;
+#if !LINUX
 	char *cp, *special;
 	struct statfs *mp;
+#endif
 	int n;
 	
 	if ((progname = strrchr(*argv, '/')))
@@ -292,7 +299,11 @@
 				      optarg, sizeof(gVolumeName) - 1);
 			if (n == 0)
 				fatal("name required with -v option");
+#if LINUX
+			strncpy(gVolumeName, optarg, sizeof(gVolumeName));
+#else
 			strlcpy(gVolumeName, optarg, sizeof(gVolumeName));
+#endif
 			break;
 
 		case '?':
@@ -321,6 +332,9 @@
 		if (argc != 1)
 			usage();
 
+#if LINUX
+		(void) sprintf(blkdevice, "%s", argv[0]);
+#else
 		special = argv[0];
 		cp = strrchr(special, '/');
 		if (cp != 0)
@@ -329,12 +343,16 @@
 			special++;
 		(void) snprintf(rawdevice, sizeof(rawdevice), "%sr%s", _PATH_DEV, special);
 		(void) snprintf(blkdevice, sizeof(blkdevice), "%s%s", _PATH_DEV, special);
+#endif
 	}
 
 	if (gPartitionSize == 0) {
 		/*
 		 * Check if target device is aready mounted
 		 */
+#if LINUX
+		//FIXME
+#else
 		n = getmntinfo(&mp, MNT_NOWAIT);
 		if (n == 0)
 			fatal("%s: getmntinfo: %s", blkdevice, strerror(errno));
@@ -344,10 +362,14 @@
 				fatal("%s is mounted on %s", blkdevice, mp->f_mntonname);
 			++mp;
 		}
+#endif
 	}
-
-	if (hfs_newfs(rawdevice) < 0) {
+	if (hfs_newfs(blkdevice) < 0) {
+#if LINUX
+		err(1, "cannot create filesystem on %s", blkdevice);
+#else
 		err(1, "cannot create filesystem on %s", rawdevice);
+#endif
 	}
 
 	exit(0);
@@ -668,8 +690,10 @@
 	int fso = -1;
 	int retval = 0;
 	hfsparams_t defaults = {0};
+#if !LINUX
 	UInt64 maxPhysPerIO = 0;
-	
+#endif
+
 	if (gPartitionSize) {
 		dip.sectorSize = kBytesPerSector;
 		dip.physTotalSectors = dip.totalSectors = gPartitionSize / kBytesPerSector;
@@ -686,14 +710,43 @@
 		}
 
 		dip.fd = fso;
+#if !LINUX
 		fcntl(fso, F_NOCACHE, 1);
-
+#endif
 		if (fso < 0)
 			fatal("%s: %s", device, strerror(errno));
 
 		if (fstat( fso, &stbuf) < 0)
 			fatal("%s: %s", device, strerror(errno));
 
+#if LINUX
+		dip.sectorSize = 512;
+		dip.physSectorSize = 512;
+		dip.physSectorsPerIO = 1;
+#ifndef        BLKGETSIZE
+#define        BLKGETSIZE              _IO(0x12,96)
+#endif
+#ifndef        BLKGETSIZE64
+#define BLKGETSIZE64           _IOR(0x12,114,size_t)
+#endif
+        
+		if (S_ISREG(stbuf.st_mode)) {
+			dip.totalSectors = stbuf.st_size / 512;
+		} 
+		else if (S_ISBLK(stbuf.st_mode)) {
+			unsigned long size;
+			u_int64_t size64;
+			if (!ioctl(fso, BLKGETSIZE64, &size64))
+				dip.totalSectors = size64 / 512;
+			else if (!ioctl(fso, BLKGETSIZE, &size))
+				dip.totalSectors = size;
+			else
+				fatal("%s: %s", device, strerror(errno));
+		} 
+		else
+			fatal("%s: is not a block device", device);
+	}
+#else
 		if (ioctl(fso, DKIOCGETBLOCKSIZE, &dip.physSectorSize) < 0)
 			fatal("%s: %s", device, strerror(errno));
 
@@ -733,6 +786,7 @@
 
 	dip.sectorSize = kBytesPerSector;
 	dip.totalSectors = dip.physTotalSectors * dip.physSectorSize / dip.sectorSize;
+#endif
 
 	dip.sectorOffset = 0;
 	time(&createtime);
--- a/newfs_hfs.tproj/newfs_hfs.h	2010-06-17 02:06:48.000000000 +0200
+++ b/newfs_hfs.tproj/newfs_hfs.h	2012-02-02 23:29:48.000000000 +0100
@@ -20,8 +20,12 @@
  * 
  * @APPLE_LICENSE_HEADER_END@
  */
- 
-#include <CoreFoundation/CFBase.h>
+
+#if LINUX
+#include "missing.h"
+#else
+#include <CoreFoundation/CFBase.h>*/
+#endif
 
 /*
  * Mac OS Finder flags
